<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pokémon Adventures - Red Chapter</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { 
            width: 100%; height: 100%; 
            background: #000; 
            overflow: hidden; 
            font-family: 'Press Start 2P', monospace;
        }
        
        #loadingScreen {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: #000; color: #fff;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 9999; font-size: 12px;
        }
        
        #loadingScreen .progress {
            width: 200px; height: 20px;
            background: #333; border: 2px solid #fff;
            margin-top: 20px;
        }
        
        #loadingScreen .progress-fill {
            height: 100%; background: #4ade80;
            width: 0%; transition: width 0.3s;
        }
        
        #gameContainer {
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            width: 100%; height: 100%;
            background: linear-gradient(180deg, #1a1a2e 0%, #0d1b2a 100%);
        }
        
        canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            border: 4px solid #444;
            border-radius: 4px;
        }
        
        .controls {
            position: fixed; bottom: 10px; left: 0; right: 0;
            display: flex; justify-content: space-between;
            padding: 0 15px; z-index: 1000;
        }
        
        .dpad {
            display: grid;
            grid-template: repeat(3, 36px) / repeat(3, 36px);
            gap: 2px;
        }
        
        .dpad button {
            background: rgba(50, 50, 70, 0.9);
            border: 2px solid #666;
            color: #fff;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .dpad button:active { background: #e63946; }
        .dpad .up { grid-column: 2; grid-row: 1; }
        .dpad .left { grid-column: 1; grid-row: 2; }
        .dpad .right { grid-column: 3; grid-row: 2; }
        .dpad .down { grid-column: 2; grid-row: 3; }
        
        .action-buttons { display: flex; gap: 8px; align-items: flex-end; }
        
        .action-buttons button {
            width: 50px; height: 50px;
            border-radius: 50%;
            font-size: 12px; font-weight: bold;
            border: 3px solid;
            cursor: pointer;
            font-family: inherit;
        }
        
        .btn-a { background: #e63946; border-color: #c1121f; color: white; }
        .btn-b { background: #457b9d; border-color: #1d3557; color: white; }
        
        /* FRLG-ish message box */
        #dialogBox {
            display: none;
            position: fixed;
            bottom: 100px; left: 50%;
            transform: translateX(-50%);
            width: 90%; max-width: 480px;
            background: #f7f3e8;
            border: 4px solid #1f2a44;
            border-radius: 8px;
            padding: 12px;
            font-size: 11px;
            line-height: 1.8;
            z-index: 2000;
            box-shadow: 0 10px 0 rgba(0,0,0,0.35);
        }

        /* Captures taps anywhere to advance dialog on iPad */
        #tapOverlay {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 1500;
            background: transparent;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        /* Debug (enable with ?debug=1) */
        #debugBar {
            display: none;
            position: fixed;
            top: 6px;
            left: 6px;
            z-index: 9000;
            background: rgba(0,0,0,0.75);
            color: #fff;
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 9px;
            line-height: 1.35;
            max-width: 90vw;
            word-break: break-word;
        }
        #dialogBox .speaker {
            font-weight: bold; color: #1f2a44;
            margin-bottom: 6px; font-size: 10px;
        }
        
        #dialogBox .text { color: #1b1b1b; }
        #dialogBox .continue { 
            text-align: right; font-size: 8px; 
            color: #666; margin-top: 8px;
            animation: blink 1s infinite;
        }
        
        @keyframes blink { 50% { opacity: 0; } }
        
        #battleScreen {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(180deg, #87ceeb 0%, #98d8aa 100%);
            z-index: 3000;
            flex-direction: column;
        }
        
        .battle-field {
            flex: 1; display: flex; flex-direction: column;
            justify-content: space-around; padding: 15px;
        }
        
        .pokemon-slot {
            display: flex; align-items: center; gap: 15px;
        }
        
        .enemy-slot { justify-content: flex-end; }
        .player-slot { justify-content: flex-start; }
        
        .pokemon-sprite {
            width: 80px; height: 80px;
            image-rendering: pixelated;
        }
        
        .pokemon-info {
            background: #fff;
            border: 3px solid #333;
            border-radius: 8px;
            padding: 8px 12px;
            min-width: 150px;
        }
        
        .pokemon-name { font-size: 11px; font-weight: bold; }
        .pokemon-level { font-size: 9px; color: #666; }
        
        .hp-bar {
            height: 6px; background: #333;
            border-radius: 3px; margin-top: 4px;
        }
        
        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #22c55e);
            transition: width 0.3s;
            border-radius: 3px;
        }
        
        .hp-fill.low { background: linear-gradient(90deg, #fbbf24, #f59e0b); }
        .hp-fill.critical { background: linear-gradient(90deg, #ef4444, #dc2626); }
        
        .battle-menu {
            background: #fff;
            border-top: 4px solid #333;
            padding: 12px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .battle-menu button {
            padding: 12px;
            font-size: 11px;
            font-family: inherit;
            border: 3px solid #333;
            border-radius: 6px;
            cursor: pointer;
        }
        
        .battle-menu .fight { background: #ef4444; color: white; }
        .battle-menu .bag { background: #f59e0b; color: white; }
        .battle-menu .pokemon { background: #22c55e; color: white; }
        .battle-menu .run { background: #64748b; color: white; }
        
        .battle-log {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
            padding: 8px 12px;
            font-size: 10px;
            min-height: 40px;
        }

        .battle-ok {
            background: #fff;
            border-top: 4px solid #333;
            padding: 12px;
            display: none;
        }

        .battle-ok button {
            width: 100%;
            padding: 14px 12px;
            font-size: 12px;
            font-family: inherit;
            border: 3px solid #333;
            border-radius: 8px;
            cursor: pointer;
            background: #111827;
            color: #fff;
        }

        .moves-menu { display: none; background: #fff; border-top: 4px solid #333; padding: 12px; }
        .moves-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        
        .move-btn {
            padding: 10px; font-size: 10px;
            font-family: inherit; border: 3px solid #333;
            border-radius: 6px; cursor: pointer; text-align: left;
        }
        
        .move-btn .move-name { font-weight: bold; }
        .move-btn .move-pp { font-size: 8px; color: #333; }
        
        .type-normal { background: #a8a878; color: white; }
        .type-electric { background: #f8d030; color: #333; }
        .type-water { background: #6890f0; color: white; }
        .type-psychic { background: #f85888; color: white; }
        .type-grass { background: #78c850; color: white; }
        .type-fire { background: #f08030; color: white; }
        .type-poison { background: #a040a0; color: white; }
        
        .back-btn {
            margin-top: 8px; padding: 8px; width: 100%;
            background: #64748b; color: white;
            border: 2px solid #333; border-radius: 4px;
            cursor: pointer; font-family: inherit; font-size: 10px;
        }
        
        #titleScreen {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(180deg, #1e3a5f 0%, #0d1b2a 100%);
            display: none; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 5000; color: white;
        }
        
        #titleScreen h1 { font-size: 20px; margin-bottom: 8px; text-shadow: 2px 2px #000; color: #ffd700; }
        #titleScreen h2 { font-size: 11px; margin-bottom: 30px; color: #87ceeb; }
        
        #titleScreen button {
            padding: 12px 30px; font-size: 12px;
            font-family: inherit; background: #e63946; color: white;
            border: 3px solid #fff; border-radius: 8px;
            cursor: pointer; margin: 8px;
        }
        
        #titleScreen button:hover { background: #c1121f; }
        
        .title-pokemon { width: 96px; height: 96px; margin-bottom: 15px; image-rendering: pixelated; }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div>Loading sprites...</div>
        <div class="progress"><div class="progress-fill" id="progressFill"></div></div>
        <div id="loadingText" style="margin-top: 10px; font-size: 10px;"></div>
    </div>
    
    <div id="titleScreen">
        <img class="title-pokemon" id="titlePokemon" src="" alt="Poliwhirl">
        <h1>POKÉMON</h1>
        <h2>ADVENTURES - RED CHAPTER</h2>
        <button onclick="startNewGame()">NEW GAME</button>
        <button onclick="loadGame()">CONTINUE</button>
    </div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>
    
    <div class="controls">
        <div class="dpad">
            <button class="up" ontouchstart="startMove('up')" ontouchend="stopMove()" onmousedown="startMove('up')" onmouseup="stopMove()">▲</button>
            <button class="left" ontouchstart="startMove('left')" ontouchend="stopMove()" onmousedown="startMove('left')" onmouseup="stopMove()">◄</button>
            <button class="right" ontouchstart="startMove('right')" ontouchend="stopMove()" onmousedown="startMove('right')" onmouseup="stopMove()">►</button>
            <button class="down" ontouchstart="startMove('down')" ontouchend="stopMove()" onmousedown="startMove('down')" onmouseup="stopMove()">▼</button>
        </div>
        <div class="action-buttons">
            <button class="btn-b" onclick="handleB()">B</button>
            <button class="btn-a" onclick="handleA()">A</button>
        </div>
    </div>

    <div id="tapOverlay" onclick="tapAdvance(event)" ontouchstart="tapAdvance(event); return false"></div>

    <div id="dialogBox" onclick="tapAdvance(event)" ontouchstart="tapAdvance(event); return false">
        <div class="speaker"></div>
        <div class="text"></div>
        <div class="continue">▼ Press A</div>
    </div>

    <div id="debugBar"></div>
    
    <div id="battleScreen">
        <div class="battle-field">
            <div class="pokemon-slot enemy-slot">
                <div class="pokemon-info">
                    <div class="pokemon-name" id="enemyName">RATTATA</div>
                    <div class="pokemon-level" id="enemyLevel">Lv. 3</div>
                    <div class="hp-bar"><div class="hp-fill" id="enemyHp"></div></div>
                </div>
                <img class="pokemon-sprite" id="enemySprite" src="">
            </div>
            <div class="pokemon-slot player-slot">
                <img class="pokemon-sprite" id="playerSprite" src="">
                <div class="pokemon-info">
                    <div class="pokemon-name" id="playerName">PIKACHU</div>
                    <div class="pokemon-level" id="playerLevel">Lv. 5</div>
                    <div class="hp-bar"><div class="hp-fill" id="playerHp"></div></div>
                    <div style="font-size: 8px; margin-top: 3px;"><span id="playerCurrentHp">20</span>/<span id="playerMaxHp">20</span></div>
                </div>
            </div>
        </div>
        <div class="battle-log" id="battleLog">Um POKeMON selvagem apareceu!</div>
        <div class="battle-ok" id="battleOk">
            <button id="battleOkBtn" onclick="battleOk()">OK</button>
        </div>
        <div class="battle-menu" id="battleMenu">
            <button class="fight" onclick="showMoves()">FIGHT</button>
            <button class="bag" onclick="useBag()">BAG</button>
            <button class="pokemon" onclick="showPokemon()">POKéMON</button>
            <button class="run" onclick="tryRun()">RUN</button>
        </div>
        <div class="moves-menu" id="movesMenu">
            <div class="moves-grid" id="movesGrid"></div>
            <button class="back-btn" onclick="hideMoves()">BACK</button>
        </div>
    </div>

    <script>
    // ==================== CONFIG ====================
    const TILE = 16;
    const SCALE = 2;
    const ST = TILE * SCALE; // Scaled tile
    const VW = 15; // View width in tiles
    const VH = 11; // View height in tiles
    
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = VW * ST;
    canvas.height = VH * ST;
    
    // ==================== SPRITE SOURCES ====================
    const GITHUB_BASE = 'https://raw.githubusercontent.com/pret/pokefirered/master/';
    
    const SPRITE_URLS = {
        // Player & NPCs (16x32 sprite sheets with walk animations)
        red: GITHUB_BASE + 'graphics/object_events/pics/people/red_normal.png',
        blue: GITHUB_BASE + 'graphics/object_events/pics/people/blue.png',
        brock: GITHUB_BASE + 'graphics/object_events/pics/people/brock.png',
        oak: GITHUB_BASE + 'graphics/object_events/pics/people/prof_oak.png',
        mom: GITHUB_BASE + 'graphics/object_events/pics/people/mom.png',
        girl: GITHUB_BASE + 'graphics/object_events/pics/people/lass.png',
        green: GITHUB_BASE + 'graphics/object_events/pics/people/green.png',
        
        // Pokemon overworld sprites
        pikachuOW: GITHUB_BASE + 'graphics/object_events/pics/pokemon/pikachu.png',
        
        // Battle sprites (from Showdown - already colored)
        pikachuBattle: 'https://play.pokemonshowdown.com/sprites/gen3frlg/pikachu.png',
        pikachuBack: 'https://play.pokemonshowdown.com/sprites/gen3-back/pikachu.png',
        rattata: 'https://play.pokemonshowdown.com/sprites/gen3frlg/rattata.png',
        pidgey: 'https://play.pokemonshowdown.com/sprites/gen3frlg/pidgey.png',
        staryu: 'https://play.pokemonshowdown.com/sprites/gen3frlg/staryu.png',
        
        // MANGA KEY POKEMON - Red's Team
        poliwhirl: 'https://play.pokemonshowdown.com/sprites/gen3frlg/poliwhirl.png',
        poliwhirlBack: 'https://play.pokemonshowdown.com/sprites/gen3-back/poliwhirl.png',
        poliwrath: 'https://play.pokemonshowdown.com/sprites/gen3frlg/poliwrath.png',
        poliwrathBack: 'https://play.pokemonshowdown.com/sprites/gen3-back/poliwrath.png',
        bulbasaur: 'https://play.pokemonshowdown.com/sprites/gen3frlg/bulbasaur.png',
        bulbasaurBack: 'https://play.pokemonshowdown.com/sprites/gen3-back/bulbasaur.png',
        ivysaur: 'https://play.pokemonshowdown.com/sprites/gen3frlg/ivysaur.png',
        venusaur: 'https://play.pokemonshowdown.com/sprites/gen3frlg/venusaur.png',
        snorlax: 'https://play.pokemonshowdown.com/sprites/gen3frlg/snorlax.png',
        gyarados: 'https://play.pokemonshowdown.com/sprites/gen3frlg/gyarados.png',
        
        // Blue's Pokemon
        charmander: 'https://play.pokemonshowdown.com/sprites/gen3frlg/charmander.png',
        charmeleon: 'https://play.pokemonshowdown.com/sprites/gen3frlg/charmeleon.png',
        charizard: 'https://play.pokemonshowdown.com/sprites/gen3frlg/charizard.png',
        
        // Green's Pokemon (thief girl)
        squirtle: 'https://play.pokemonshowdown.com/sprites/gen3frlg/squirtle.png',
        wartortle: 'https://play.pokemonshowdown.com/sprites/gen3frlg/wartortle.png',
        
        // Legendary & Story Pokemon
        mew: 'https://play.pokemonshowdown.com/sprites/gen3frlg/mew.png',
        kangaskhan: 'https://play.pokemonshowdown.com/sprites/gen3frlg/kangaskhan.png',
        
        // Team Rocket Pokemon
        nidoking: 'https://play.pokemonshowdown.com/sprites/gen3frlg/nidoking.png',
        koffing: 'https://play.pokemonshowdown.com/sprites/gen3frlg/koffing.png',
        ekans: 'https://play.pokemonshowdown.com/sprites/gen3frlg/ekans.png',
        arbok: 'https://play.pokemonshowdown.com/sprites/gen3frlg/arbok.png',
        geodude: 'https://play.pokemonshowdown.com/sprites/gen3frlg/geodude.png',
        onix: 'https://play.pokemonshowdown.com/sprites/gen3frlg/onix.png',

        // Optional remote tilesets (not used by default; we generate our own tiles for stability/style control)
        generalTiles: GITHUB_BASE + 'data/tilesets/primary/general/tiles.png',
        buildingTiles: GITHUB_BASE + 'data/tilesets/primary/building/tiles.png'
    };
    
    // Loaded images
    const sprites = {};
    let loadedCount = 0;
    const totalSprites = Object.keys(SPRITE_URLS).length;
    
    // ==================== COLORS (FRLG-ish, but original) ====================
    const C = {
        grass: '#6fbf4a', grass2: '#5aa83a', grass3: '#4f9533',
        path: '#d7bf8a', path2: '#c9ad71', path3: '#b7975f',
        water: '#4a87c9', water2: '#3974b6', water3: '#2f619c',
        tree: '#2b7f3a', tree2: '#256d33', trunk: '#8a5a2b',
        roofR: '#c23d3d', roofR2: '#a62e2e',
        roofB: '#2f6db6', roofB2: '#255a96',
        roofG: '#2f9b6b', roofG2: '#237b55',
        wall: '#efe4c7', wall2: '#e2d4b2',
        fence: '#caa46b', fence2: '#b99258',
        sign: '#a46a2c',
        shadow: '#1b1b1b',
        flower: '#e46aa3'
    };
    
    // ==================== TILE TYPES ====================
    const T = {
        GRASS: 0, PATH: 1, WATER: 2, TREE: 3,
        HOUSE_RED: 4, HOUSE_BLUE: 5, LAB: 6,
        FENCE: 7, SIGN: 8, TALL_GRASS: 9,
        FLOWER: 10, LEDGE: 11, WARP: 13, NPC: 14
        , FLOOR_IN: 15, WALL_IN: 16, TABLE: 17, SHELF: 18
    };
    
    const SOLID = [T.WATER, T.TREE, T.HOUSE_RED, T.HOUSE_BLUE, T.LAB, T.FENCE, T.NPC, T.WALL_IN, T.TABLE, T.SHELF];
    
    // ==================== MAPS ====================
    const MAPS = {
        pallet_town: {
            w: 20, h: 18,
            data: (() => {
                const w = 20, h = 18;
                const m = new Array(w * h).fill(T.GRASS);

                // Border trees (keep south gate open to Route 1).
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        if (x === 0 || x === w - 1 || y === 0) m[y * w + x] = T.TREE;
                    }
                }

                // South transition row and gate.
                for (let x = 0; x < w; x++) m[(h - 1) * w + x] = T.TALL_GRASS;
                m[(h - 1) * w + 9] = T.WARP;
                m[(h - 1) * w + 10] = T.WARP;

                // Main road + cross road.
                for (let y = 1; y <= 16; y++) {
                    m[y * w + 9] = T.PATH;
                    m[y * w + 10] = T.PATH;
                }
                for (let x = 2; x <= 17; x++) m[8 * w + x] = T.PATH;

                // Player house (left), rival house (right), Oak lab (south-center).
                for (let y = 3; y <= 5; y++) for (let x = 3; x <= 5; x++) m[y * w + x] = T.HOUSE_RED;
                for (let y = 3; y <= 5; y++) for (let x = 13; x <= 15; x++) m[y * w + x] = T.HOUSE_BLUE;
                for (let y = 9; y <= 11; y++) for (let x = 7; x <= 11; x++) m[y * w + x] = T.LAB;

                // Building entrances as warp tiles.
                m[6 * w + 4] = T.WARP;
                m[6 * w + 14] = T.WARP;
                m[12 * w + 9] = T.WARP;

                // Town details.
                m[7 * w + 11] = T.SIGN;
                m[2 * w + 2] = T.FLOWER;
                m[2 * w + 17] = T.FLOWER;
                m[14 * w + 3] = T.FLOWER;
                m[14 * w + 16] = T.FLOWER;
                for (let x = 6; x <= 12; x++) m[10 * w + x] = T.FENCE;

                return m;
            })(),
            warps: [
                {x:4,y:6,to:'player_house',tx:3,ty:6},
                {x:14,y:6,to:'rival_house',tx:3,ty:6},
                {x:9,y:12,to:'oak_lab',tx:5,ty:10},
                {x:9,y:17,to:'route1',tx:9,ty:23},
                {x:10,y:17,to:'route1',tx:10,ty:23}
            ],
            npcs: [
                {x:15,y:10,name:'Girl',sprite:'girl',dialog:[
                    'Bem-vindo a PALLET TOWN!',
                    'Ouviu o boato? Dizem que viram uma luz estranha na floresta!',
                    'O Professor OAK esta investigando isso no laboratorio...'
                ]},
                {x:13,y:7,name:'Blue',sprite:'blue',dialog:[
                    '...Ah. Voce, RED.',
                    'O velho falou de um POKeMON raro avistado por aqui.',
                    'Nao ache que vai chegar antes de mim.',
                    'Eu sempre estou um passo a frente. Ate mais.'
                ]}
            ],
            enc: null
        },
        
        route1: {
            w: 20, h: 25,
            data: (() => {
                let m = [];
                for (let y = 0; y < 25; y++) {
                    for (let x = 0; x < 20; x++) {
                        if (x === 0 || x === 19) m.push(T.TREE);
                        else if (y === 24 && (x === 9 || x === 10)) m.push(T.WARP);
                        else if (y === 0 && (x === 9 || x === 10)) m.push(T.WARP);
                        else if (x === 9 || x === 10) m.push(T.PATH);
                        else if ((y >= 4 && y <= 9 && (x <= 6 || x >= 13)) || (y >= 14 && y <= 18 && (x <= 5 || x >= 14))) m.push(T.TALL_GRASS);
                        else m.push(T.GRASS);
                    }
                }
                return m;
            })(),
            warps: [
                {x:9,y:0,to:'viridian',tx:9,ty:16},
                {x:10,y:0,to:'viridian',tx:10,ty:16},
                {x:9,y:24,to:'pallet_town',tx:9,ty:16},
                {x:10,y:24,to:'pallet_town',tx:10,ty:16}
            ],
            npcs: [],
            enc: {pokemon:[{name:'RATTATA',spr:'rattata',lv:[2,4],rate:55},{name:'PIDGEY',spr:'pidgey',lv:[2,5],rate:45}],rate:12}
        },

        // Minimal Viridian City (static layout, story-first; no RNG required)
        viridian: {
            w: 20, h: 18,
            data: (() => {
                const w = 20, h = 18;
                const m = new Array(w * h).fill(T.GRASS);
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.TREE;
                    }
                }
                // Main road (south <-> north)
                for (let y = 1; y < h - 1; y++) {
                    m[y * w + 9] = T.PATH;
                    m[y * w + 10] = T.PATH;
                }
                // Plaza
                for (let y = 6; y <= 9; y++) for (let x = 6; x <= 13; x++) m[y * w + x] = T.PATH;
                // WARP tiles
                m[0 * w + 9] = T.WARP; m[0 * w + 10] = T.WARP;
                m[(h - 1) * w + 9] = T.WARP; m[(h - 1) * w + 10] = T.WARP;
                // Forest gate (east)
                m[8 * w + (w - 1)] = T.WARP;
                // Simple sign
                m[10 * w + 8] = T.SIGN;
                return m;
            })(),
            warps: [
                {x:9,y:17,to:'route1',tx:9,ty:1},
                {x:10,y:17,to:'route1',tx:10,ty:1},
                {x:9,y:0,to:'route2',tx:9,ty:23},
                {x:10,y:0,to:'route2',tx:10,ty:23},
                {x:19,y:8,to:'viridian_forest',tx:2,ty:12},
            ],
            npcs: [
                {x:10,y:8,name:'Girl',sprite:'girl',dialog:[
                    'VIRIDIAN CITY...',
                    'Dizem que o GINASIO esta fechado.',
                    'E que a floresta esta... estranha.'
                ]},
            ],
            enc: null
        },

        // Route 2: Viridian -> Pewter (no RNG when storyLock=true)
        route2: {
            w: 20, h: 25,
            data: (() => {
                const w = 20, h = 25;
                const m = new Array(w * h).fill(T.GRASS);
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        if (x === 0 || x === w - 1) m[y * w + x] = T.TREE;
                        else if (y === 0 || y === h - 1) m[y * w + x] = T.TREE;
                    }
                }
                // Path
                for (let y = 1; y < h - 1; y++) {
                    m[y * w + 9] = T.PATH;
                    m[y * w + 10] = T.PATH;
                }
                // Tall grass patches
                for (let y = 6; y <= 10; y++) for (let x = 3; x <= 6; x++) m[y * w + x] = T.TALL_GRASS;
                for (let y = 13; y <= 17; y++) for (let x = 13; x <= 16; x++) m[y * w + x] = T.TALL_GRASS;

                // Warps
                m[(h - 1) * w + 9] = T.WARP; m[(h - 1) * w + 10] = T.WARP;
                m[0 * w + 9] = T.WARP; m[0 * w + 10] = T.WARP;
                return m;
            })(),
            warps: [
                {x:9,y:24,to:'viridian',tx:9,ty:1},
                {x:10,y:24,to:'viridian',tx:10,ty:1},
                {x:9,y:0,to:'pewter',tx:9,ty:16},
                {x:10,y:0,to:'pewter',tx:10,ty:16},
            ],
            npcs: [],
            enc: {pokemon:[{name:'RATTATA',spr:'rattata',lv:[3,5],rate:50},{name:'PIDGEY',spr:'pidgey',lv:[3,6],rate:50}],rate:10}
        },

        // Pewter City (minimal; Pikachu arc will be triggered here)
        pewter: {
            w: 20, h: 18,
            data: (() => {
                const w = 20, h = 18;
                const m = new Array(w * h).fill(T.GRASS);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.TREE;
                }
                for (let y = 1; y < h - 1; y++) {
                    m[y * w + 9] = T.PATH;
                    m[y * w + 10] = T.PATH;
                }
                for (let y = 6; y <= 11; y++) for (let x = 6; x <= 13; x++) m[y * w + x] = T.PATH;
                // Pewter Gym
                for (let y = 3; y <= 5; y++) for (let x = 8; x <= 11; x++) m[y * w + x] = T.LAB;
                m[6 * w + 9] = T.WARP;
                // North exit to Route 3
                m[0 * w + 9] = T.WARP; m[0 * w + 10] = T.WARP;
                // Warps (south back to route2)
                m[(h - 1) * w + 9] = T.WARP; m[(h - 1) * w + 10] = T.WARP;
                // Sign near center
                m[11 * w + 8] = T.SIGN;
                return m;
            })(),
            warps: [
                {x:9,y:17,to:'route2',tx:9,ty:1},
                {x:10,y:17,to:'route2',tx:10,ty:1},
                {x:9,y:6,to:'pewter_gym',tx:5,ty:9},
                {x:9,y:0,to:'route3',tx:1,ty:8},
                {x:10,y:0,to:'route3',tx:1,ty:9}
            ],
            npcs: [
                {x:10,y:9,name:'Girl',sprite:'girl',dialog:[
                    'PEWTER CITY.',
                    'A cidade das rochas.',
                    '...E dizem que ha um POKeMON estranho por aqui.'
                ]},
            ],
            enc: null
        },

        route3: {
            w: 20, h: 16,
            data: (() => {
                const w = 20, h = 16;
                const m = new Array(w * h).fill(T.GRASS);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.TREE;
                }
                for (let x = 1; x < w - 1; x++) {
                    m[8 * w + x] = T.PATH;
                    m[9 * w + x] = T.PATH;
                }
                for (let y = 3; y <= 5; y++) for (let x = 4; x <= 7; x++) m[y * w + x] = T.TALL_GRASS;
                for (let y = 10; y <= 12; y++) for (let x = 12; x <= 15; x++) m[y * w + x] = T.TALL_GRASS;
                m[8 * w + 0] = T.WARP; m[9 * w + 0] = T.WARP;
                m[8 * w + (w - 1)] = T.WARP; m[9 * w + (w - 1)] = T.WARP;
                return m;
            })(),
            warps: [
                {x:0,y:8,to:'pewter',tx:9,ty:1},
                {x:0,y:9,to:'pewter',tx:10,ty:1},
                {x:19,y:8,to:'mt_moon',tx:1,ty:8},
                {x:19,y:9,to:'mt_moon',tx:1,ty:9}
            ],
            npcs: [],
            enc: {pokemon:[{name:'RATTATA',spr:'rattata',lv:[6,8],rate:50},{name:'PIDGEY',spr:'pidgey',lv:[6,8],rate:50}],rate:10}
        },

        mt_moon: {
            w: 24, h: 16,
            data: (() => {
                const w = 24, h = 16;
                const m = new Array(w * h).fill(T.FLOOR_IN);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.WALL_IN;
                }
                m[8 * w + 0] = T.WARP; m[9 * w + 0] = T.WARP;
                m[8 * w + (w - 1)] = T.WARP; m[9 * w + (w - 1)] = T.WARP;
                m[4 * w + 6] = T.TABLE; m[4 * w + 17] = T.TABLE;
                m[10 * w + 9] = T.TABLE; m[10 * w + 14] = T.TABLE;
                m[2 * w + 11] = T.SHELF;
                return m;
            })(),
            warps: [
                {x:0,y:8,to:'route3',tx:18,ty:8},
                {x:0,y:9,to:'route3',tx:18,ty:9},
                {x:23,y:8,to:'cerulean',tx:1,ty:10},
                {x:23,y:9,to:'cerulean',tx:1,ty:11}
            ],
            npcs: [],
            enc: null
        },

        cerulean: {
            w: 22, h: 18,
            data: (() => {
                const w = 22, h = 18;
                const m = new Array(w * h).fill(T.GRASS);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.TREE;
                }
                for (let y = 1; y < h - 1; y++) { m[y * w + 10] = T.PATH; m[y * w + 11] = T.PATH; }
                for (let x = 2; x < w - 2; x++) m[9 * w + x] = T.PATH;
                for (let y = 4; y <= 6; y++) for (let x = 13; x <= 16; x++) m[y * w + x] = T.WATER;
                m[10 * w + 0] = T.WARP; m[11 * w + 0] = T.WARP;
                m[10 * w + (w - 1)] = T.WARP; m[11 * w + (w - 1)] = T.WARP;
                return m;
            })(),
            warps: [
                {x:0,y:10,to:'mt_moon',tx:22,ty:8},
                {x:0,y:11,to:'mt_moon',tx:22,ty:9},
                {x:21,y:10,to:'vermilion',tx:1,ty:10},
                {x:21,y:11,to:'vermilion',tx:1,ty:11}
            ],
            npcs: [],
            enc: null
        },

        vermilion: {
            w: 22, h: 18,
            data: (() => {
                const w = 22, h = 18;
                const m = new Array(w * h).fill(T.GRASS);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.TREE;
                }
                for (let y = 1; y < h - 1; y++) { m[y * w + 10] = T.PATH; m[y * w + 11] = T.PATH; }
                for (let x = 2; x < w - 2; x++) m[10 * w + x] = T.PATH;
                for (let y = 3; y <= 6; y++) for (let x = 15; x <= 20; x++) m[y * w + x] = T.WATER;
                m[10 * w + 0] = T.WARP; m[11 * w + 0] = T.WARP;
                m[10 * w + (w - 1)] = T.WARP; m[11 * w + (w - 1)] = T.WARP;
                return m;
            })(),
            warps: [
                {x:0,y:10,to:'cerulean',tx:20,ty:10},
                {x:0,y:11,to:'cerulean',tx:20,ty:11},
                {x:21,y:10,to:'lavender',tx:1,ty:10},
                {x:21,y:11,to:'lavender',tx:1,ty:11}
            ],
            npcs: [],
            enc: null
        },

        lavender: {
            w: 22, h: 18,
            data: (() => {
                const w = 22, h = 18;
                const m = new Array(w * h).fill(T.GRASS);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.TREE;
                }
                for (let y = 1; y < h - 1; y++) { m[y * w + 10] = T.PATH; m[y * w + 11] = T.PATH; }
                for (let x = 3; x <= 18; x++) m[10 * w + x] = T.PATH;
                for (let y = 4; y <= 6; y++) for (let x = 5; x <= 7; x++) m[y * w + x] = T.LAB;
                m[10 * w + 0] = T.WARP; m[11 * w + 0] = T.WARP;
                m[10 * w + (w - 1)] = T.WARP; m[11 * w + (w - 1)] = T.WARP;
                return m;
            })(),
            warps: [
                {x:0,y:10,to:'vermilion',tx:20,ty:10},
                {x:0,y:11,to:'vermilion',tx:20,ty:11},
                {x:21,y:10,to:'saffron',tx:1,ty:10},
                {x:21,y:11,to:'saffron',tx:1,ty:11}
            ],
            npcs: [],
            enc: null
        },

        saffron: {
            w: 22, h: 18,
            data: (() => {
                const w = 22, h = 18;
                const m = new Array(w * h).fill(T.GRASS);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.TREE;
                }
                for (let y = 1; y < h - 1; y++) { m[y * w + 10] = T.PATH; m[y * w + 11] = T.PATH; }
                for (let x = 2; x < w - 2; x++) m[9 * w + x] = T.PATH;
                for (let y = 4; y <= 7; y++) for (let x = 14; x <= 17; x++) m[y * w + x] = T.LAB;
                m[10 * w + 0] = T.WARP; m[11 * w + 0] = T.WARP;
                m[10 * w + (w - 1)] = T.WARP; m[11 * w + (w - 1)] = T.WARP;
                return m;
            })(),
            warps: [
                {x:0,y:10,to:'lavender',tx:20,ty:10},
                {x:0,y:11,to:'lavender',tx:20,ty:11},
                {x:21,y:10,to:'silph_lobby',tx:2,ty:10},
                {x:21,y:11,to:'silph_lobby',tx:2,ty:10}
            ],
            npcs: [],
            enc: null
        },

        silph_lobby: {
            w: 14, h: 12,
            data: (() => {
                const w = 14, h = 12;
                const m = new Array(w * h).fill(T.FLOOR_IN);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.WALL_IN;
                }
                m[10 * w + 2] = T.WARP;
                m[2 * w + 4] = T.SHELF; m[2 * w + 9] = T.SHELF;
                m[5 * w + 4] = T.TABLE; m[5 * w + 9] = T.TABLE;
                return m;
            })(),
            warps: [{x:2,y:10,to:'saffron',tx:20,ty:10}],
            npcs: [],
            enc: null
        },

        pewter_gym: {
            w: 12, h: 10,
            data: (() => {
                const w = 12, h = 10;
                const m = new Array(w * h).fill(T.FLOOR_IN);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || y === 0 || x === w - 1 || y === h - 1) m[y * w + x] = T.WALL_IN;
                }
                // Exit
                m[9 * w + 5] = T.WARP;
                // Rock-like props / arena
                m[3 * w + 3] = T.TABLE;
                m[3 * w + 8] = T.TABLE;
                m[5 * w + 2] = T.TABLE;
                m[5 * w + 9] = T.TABLE;
                m[1 * w + 2] = T.SHELF;
                m[1 * w + 9] = T.SHELF;
                return m;
            })(),
            warps: [{x:5,y:9,to:'pewter',tx:9,ty:7}],
            npcs: [{x:5,y:2,name:'Brock',sprite:'brock',dialog:['...']}],
            enc: null
        },
        
        viridian_forest: {
            w: 20,
            h: 25,
            data: (() => {
                let m = [];
                for (let y = 0; y < 25; y++) {
                    for (let x = 0; x < 20; x++) {
                        // Map boundaries: trees (with a gate back to Viridian)
                        if (x === 1 && y === 12) m.push(T.WARP); // Gate tile to Viridian
                        else if (x === 0 || x === 19) m.push(T.TREE);
                        // Exit south (back towards Pallet via Route 1)
                        else if (y === 24 && (x === 9 || x === 10)) m.push(T.WARP);
                        // Paths and grass
                        else if (x === 9 || x === 10) m.push(T.PATH); // Main path
                        else m.push(T.TALL_GRASS); // Lots of tall grass (deterministic)
                    }
                }
                return m;
            })(),
            warps: [
                {x:1, y:12, to: 'viridian', tx: 18, ty: 8},       // Gate back to Viridian
                {x:9, y:24, to: 'route1', tx: 9, ty: 16},         // Back towards Pallet
                {x:10, y:24, to: 'route1', tx: 10, ty: 16}
            ],
            npcs: [], // No NPCs initially in Viridian Forest for chapter 2
            // Encounters for Chapter 2: VS Bulbasaur
            enc: {
                pokemon: [
                    {name: 'RATTATA', spr: 'rattata', lv: [2, 4], rate: 40},
                    {name: 'PIDGEY', spr: 'pidgey', lv: [2, 5], rate: 40},
                    {name: 'BULBASAUR', spr: 'bulbasaur', lv: [5, 7], rate: 20} // Rare encounter for the story
                ],
                rate: 10 // Chance of encounter per step
            }
        },
        player_house: {
            w: 8, h: 8,
            data: (() => {
                const w = 8, h = 8;
                const m = new Array(w * h).fill(T.FLOOR_IN);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || y === 0 || x === w - 1 || y === h - 1) m[y * w + x] = T.WALL_IN;
                }
                m[6 * w + 3] = T.WARP; // door
                // Simple furniture
                m[3 * w + 3] = T.TABLE;
                m[2 * w + 6] = T.SHELF;
                return m;
            })(),
            warps: [{x:3,y:6,to:'pallet_town',tx:4,ty:6}],
            npcs: [{x:5,y:3,name:'Mom',sprite:'mom',dialog:['RED! Go see Professor OAK!','He has something for you!']}],
            enc: null
        },
        
        rival_house: {
            w: 8, h: 8,
            data: (() => {
                const w = 8, h = 8;
                const m = new Array(w * h).fill(T.FLOOR_IN);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || y === 0 || x === w - 1 || y === h - 1) m[y * w + x] = T.WALL_IN;
                }
                m[6 * w + 3] = T.WARP; // door
                m[3 * w + 3] = T.TABLE;
                m[2 * w + 6] = T.SHELF;
                return m;
            })(),
            warps: [{x:3,y:6,to:'pallet_town',tx:14,ty:6}],
            npcs: [{x:2,y:3,name:'Daisy',sprite:'girl',dialog:['Looking for BLUE?','He went to grandpa\'s lab.']}],
            enc: null
        },
        
        oak_lab: {
            w: 10, h: 12,
            data: (() => {
                const w = 10, h = 12;
                const m = new Array(w * h).fill(T.FLOOR_IN);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || y === 0 || x === w - 1 || y === h - 1) m[y * w + x] = T.WALL_IN;
                }
                m[11 * w + 4] = T.WARP;
                m[11 * w + 5] = T.WARP;
                // Lab props (clear center aisle).
                m[2 * w + 2] = T.SHELF;
                m[2 * w + 7] = T.SHELF;
                m[5 * w + 2] = T.TABLE;
                m[5 * w + 7] = T.TABLE;
                m[8 * w + 2] = T.TABLE;
                m[8 * w + 7] = T.TABLE;
                return m;
            })(),
            warps: [{x:4,y:11,to:'pallet_town',tx:9,ty:12},{x:5,y:11,to:'pallet_town',tx:9,ty:12}],
            npcs: [{x:4,y:2,name:'Prof. Oak',sprite:'oak',
                // Dynamic dialog based on story state (set in getOakDialog)
                dialog: null
            }],
            enc: null,
            special: 'get_poli'  // Changed from get_pikachu to get_poli (manga accurate!)
        }
    };
    
    // ==================== GAME STATE ====================
    let GS = {
        px: 10, py: 10, dir: 'down',
        map: 'pallet_town',
        // MANGA STORY FLAGS (Pokémon Adventures - Red Chapter)
        story: {
            season: 1,
            beat: 'ch1_intro',
            chapter: 1,           // Current chapter (VS Mew, VS Bulbasaur, etc)
            sawMew: false,        // Ch1: Red saw Mew in the forest
            talkedToOak: false,   // Ch1: Talked to Prof Oak first time
            gotPokedex: false,    // Ch1: Received Pokedex from Oak
            gotSaur: false,       // Ch1: Received Bulbasaur (SAUR) from Oak
            metBlue: false,       // Ch1: Met Blue (rival)
            metGreen: false,      // Ch3: Met Green (the thief girl)
            defeatedRocket1: false, // Ch3: First Team Rocket encounter
            caughtBulba: false,   // Ch2: Caught Bulbasaur
            caughtPika: false,    // Ch4: Caught Pikachu in Pewter
            brockBattleDone: false, // Ch4: First clash with Brock
        },
        // Party (manga starts with Poliwhirl, not Pikachu!)
        team: [],
        poli: {name: 'POLI', species: 'POLIWHIRL', hp: 28, maxHp: 28, lv: 8, exp: 0, spr: 'poliwhirl'},
        pika: {name: 'PIKA', species: 'PIKACHU', hp: 20, maxHp: 20, lv: 6, exp: 0, spr: 'pikachuBattle'},
        items: {potion: 3, pokeball: 5}
    };
    
    let dialog = null;
    let dialogQ = [];
    let inBattle = false;
    let battle = null;
    let moveInt = null;
    let animFrame = 0;

    // ==================== STORY SCRIPT ====================
    let STORY = null;
    let activeBeatId = null;

    async function loadStory() {
        try {
            const res = await fetch('./story/season1.ptbr.json', {cache: 'no-store'});
            if (!res.ok) throw new Error('story fetch failed');
            STORY = await res.json();
        } catch (e) {
            console.warn('Failed to load story JSON. Falling back to inline story.', e);
            STORY = null;
        }
    }

    function getBeat(id) {
        const beats = STORY && STORY.beats ? STORY.beats : null;
        if (!beats) return null;
        return beats.find(b => b && b.id === id) || null;
    }

    function getByPath(root, path) {
        const parts = String(path || '').split('.').filter(Boolean);
        let cur = root;
        for (const p of parts) {
            if (!cur || typeof cur !== 'object') return undefined;
            cur = cur[p];
        }
        return cur;
    }

    function setByPath(root, path, value) {
        const parts = String(path || '').split('.').filter(Boolean);
        if (parts.length === 0) return;
        let cur = root;
        for (let i = 0; i < parts.length - 1; i++) {
            const p = parts[i];
            if (!cur[p] || typeof cur[p] !== 'object') cur[p] = {};
            cur = cur[p];
        }
        cur[parts[parts.length - 1]] = value;
    }

    function ensureTeam(ids) {
        const want = Array.isArray(ids) ? ids : [];
        const next = [];
        for (const id of want) {
            if (id === 'poli') next.push(GS.poli);
            if (id === 'saur') next.push(GS.saur);
            if (id === 'pika') next.push(GS.pika);
        }
        if (next.length) GS.team = next;
    }

    function runActions(actions, idx = 0, onDone = null) {
        const list = Array.isArray(actions) ? actions : [];
        if (idx >= list.length) {
            if (typeof onDone === 'function') onDone();
            return;
        }
        const a = list[idx];
        if (!a || typeof a !== 'object') return runActions(list, idx + 1, onDone);

        if (a.kind === 'dialog') {
            showDialog(a.speaker || '', Array.isArray(a.lines) ? a.lines : ['...'], () => runActions(list, idx + 1, onDone));
            return;
        }
        if (a.kind === 'set') {
            setByPath(GS, a.path, a.value);
            return runActions(list, idx + 1, onDone);
        }
        if (a.kind === 'ensureTeam') {
            ensureTeam(a.value);
            return runActions(list, idx + 1, onDone);
        }
        if (a.kind === 'battle') {
            const enemy = a.enemy && typeof a.enemy === 'object'
                ? a.enemy
                : {name: 'PIDGEY', spr: 'pidgey', lv: 4, hp: 18, maxHp: 18};
            const opts = a.options && typeof a.options === 'object' ? a.options : {};
            const nextOnEnd = opts.onEnd;
            startBattle(enemy, {
                ...opts,
                scripted: opts.scripted !== false,
                onEnd: (won) => {
                    if (nextOnEnd === 'only_if_win' && !won) return;
                    runActions(list, idx + 1, onDone);
                }
            });
            return;
        }
        // Unknown action: skip
        runActions(list, idx + 1, onDone);
    }

    function playBeat(id) {
        if (activeBeatId === id) return true;
        if (activeBeatId && activeBeatId !== id) return false;
        const beat = getBeat(id);
        if (!beat) return false;
        activeBeatId = id;
        GS.story.beat = id;
        runActions(beat.actions, 0, () => {
            if (activeBeatId === id) activeBeatId = null;
            // Continue chaining story automatically when multiple beats belong to the same area.
            setTimeout(() => { tryAutoStoryBeat(); }, 220);
        });
        return true;
    }
    
    // ==================== ASSET LOADING ====================
    function createTilesetCanvas() {
        // Tile atlas: 8 columns x 4 rows. Each tile is 16x16.
        // Original pixel art tiles inspired by the FRLG feel (no ripped assets).
        const cols = 8;
        const rows = 4;
        const ts = document.createElement('canvas');
        ts.width = cols * TILE;
        ts.height = rows * TILE;
        const tctx = ts.getContext('2d');

        function px(x, y, w, h, color) {
            tctx.fillStyle = color;
            tctx.fillRect(x, y, w, h);
        }

        function dither(x0, y0, a, b) {
            for (let y = 0; y < TILE; y++) {
                for (let x = 0; x < TILE; x++) {
                    tctx.fillStyle = ((x + y) % 2 === 0) ? a : b;
                    tctx.fillRect(x0 + x, y0 + y, 1, 1);
                }
            }
        }

        function speckle(x0, y0, color, n) {
            tctx.fillStyle = color;
            for (let i = 0; i < n; i++) {
                const x = x0 + ((i * 7) % TILE);
                const y = y0 + ((i * 11) % TILE);
                tctx.fillRect(x, y, 1, 1);
            }
        }

        function tile(ax, ay, drawFn) {
            const x0 = ax * TILE;
            const y0 = ay * TILE;
            drawFn(x0, y0);
        }

        // Row 0: ground
        tile(0, 0, (x0, y0) => { dither(x0, y0, C.grass, C.grass2); speckle(x0, y0, C.grass3, 18); }); // GRASS
        tile(1, 0, (x0, y0) => { dither(x0, y0, C.path, C.path2); speckle(x0, y0, C.path3, 14); });     // PATH
        tile(2, 0, (x0, y0) => { // WATER
            px(x0, y0, TILE, TILE, C.water);
            for (let y = 2; y < TILE; y += 4) {
                for (let x = 0; x < TILE; x++) {
                    const c = (x % 6 < 3) ? C.water2 : C.water3;
                    tctx.fillStyle = c;
                    tctx.fillRect(x0 + x, y0 + y, 1, 1);
                }
            }
        });
        tile(3, 0, (x0, y0) => { dither(x0, y0, C.grass2, C.grass3); for (let x = 1; x < TILE; x += 3) px(x0 + x, y0 + 2, 1, 12, C.grass); }); // TALL_GRASS
        tile(4, 0, (x0, y0) => { // TREE
            px(x0, y0, TILE, TILE, C.tree2);
            px(x0 + 1, y0 + 1, TILE - 2, TILE - 2, C.tree);
            px(x0 + 7, y0 + 11, 2, 4, C.trunk);
            px(x0 + 3, y0 + 3, 2, 2, C.grass);
        });
        tile(5, 0, (x0, y0) => { // FENCE
            dither(x0, y0, C.fence, C.fence2);
            px(x0 + 1, y0 + 5, TILE - 2, 1, C.shadow);
            px(x0 + 1, y0 + 10, TILE - 2, 1, C.shadow);
            for (let x = 2; x < TILE; x += 4) px(x0 + x, y0 + 2, 1, 12, C.shadow);
        });
        tile(6, 0, (x0, y0) => { // SIGN
            dither(x0, y0, C.grass, C.grass2);
            px(x0 + 3, y0 + 3, 10, 6, C.wall);
            px(x0 + 4, y0 + 4, 8, 4, C.wall2);
            px(x0 + 7, y0 + 9, 2, 6, C.sign);
        });
        tile(7, 0, (x0, y0) => { dither(x0, y0, C.grass, C.grass2); px(x0 + 7, y0 + 7, 2, 2, C.flower); px(x0 + 6, y0 + 8, 1, 1, '#fff'); px(x0 + 9, y0 + 6, 1, 1, '#fff'); }); // FLOWER

        // Row 1: building palette (roof/wall/door/window + interiors)
        tile(0, 1, (x0, y0) => { dither(x0, y0, C.roofR, C.roofR2); }); // ROOF_RED
        tile(1, 1, (x0, y0) => { dither(x0, y0, C.roofB, C.roofB2); }); // ROOF_BLUE
        tile(2, 1, (x0, y0) => { dither(x0, y0, C.roofG, C.roofG2); }); // ROOF_LAB
        tile(3, 1, (x0, y0) => { dither(x0, y0, C.wall, C.wall2); });   // WALL
        tile(4, 1, (x0, y0) => { // DOOR
            dither(x0, y0, C.wall, C.wall2);
            px(x0 + 5, y0 + 4, 6, 10, '#7b4b1b');
            px(x0 + 6, y0 + 5, 4, 8, '#925b22');
            px(x0 + 9, y0 + 9, 1, 1, '#f6e05e');
        });
        tile(5, 1, (x0, y0) => { // WINDOW
            dither(x0, y0, C.wall, C.wall2);
            px(x0 + 4, y0 + 4, 8, 6, '#9bd6ff');
            px(x0 + 4, y0 + 4, 8, 1, C.shadow);
            px(x0 + 4, y0 + 9, 8, 1, C.shadow);
            px(x0 + 4, y0 + 4, 1, 6, C.shadow);
            px(x0 + 11, y0 + 4, 1, 6, C.shadow);
        });
        tile(6, 1, (x0, y0) => { // FLOOR_IN
            dither(x0, y0, '#d9c39a', '#cfb487');
            speckle(x0, y0, '#b99563', 10);
        });
        tile(7, 1, (x0, y0) => { // WALL_IN
            px(x0, y0, TILE, TILE, '#c6b18a');
            px(x0, y0, TILE, 2, '#ad976e');
            px(x0, y0 + 2, TILE, 1, '#bda57a');
        });

        // Row 2: WARP marker (subtle)
        tile(0, 2, (x0, y0) => {
            dither(x0, y0, C.path, C.path2);
            px(x0 + 4, y0 + 4, 8, 8, '#111827');
            px(x0 + 5, y0 + 5, 6, 6, '#1f2937');
            px(x0 + 7, y0 + 7, 2, 2, '#9ca3af');
        });

        // Row 2+: variants to break repetition (deterministic noise picks)
        tile(1, 2, (x0, y0) => { dither(x0, y0, C.grass2, C.grass); speckle(x0, y0, C.grass3, 26); }); // GRASS_ALT
        tile(2, 2, (x0, y0) => { dither(x0, y0, C.path2, C.path); speckle(x0, y0, C.path3, 22); });     // PATH_ALT

        // Row 3: simple interior props (original)
        tile(0, 3, (x0, y0) => { // TABLE
            px(x0, y0, TILE, TILE, '#d9c39a');
            px(x0 + 2, y0 + 4, 12, 8, '#8b5a2b');
            px(x0 + 3, y0 + 5, 10, 6, '#a0672f');
            px(x0 + 3, y0 + 12, 2, 3, '#6b3f1a');
            px(x0 + 11, y0 + 12, 2, 3, '#6b3f1a');
        });
        tile(1, 3, (x0, y0) => { // SHELF
            px(x0, y0, TILE, TILE, '#d9c39a');
            px(x0 + 2, y0 + 2, 12, 12, '#7b4b1b');
            px(x0 + 3, y0 + 3, 10, 2, '#925b22');
            px(x0 + 3, y0 + 7, 10, 2, '#925b22');
            px(x0 + 3, y0 + 11, 10, 2, '#925b22');
            // books
            px(x0 + 4, y0 + 4, 1, 2, '#ef4444');
            px(x0 + 6, y0 + 4, 1, 2, '#3b82f6');
            px(x0 + 8, y0 + 4, 1, 2, '#22c55e');
        });

        return ts;
    }

    function qs(name, dflt = '') {
        try { return (new URLSearchParams(location.search)).get(name) || dflt; }
        catch { return dflt; }
    }

    function normalizeUrl(v) {
        try {
            if (!v) return '';
            return new URL(String(v), location.href).toString();
        } catch {
            return '';
        }
    }

    async function tryLoadExternalTileset() {
        // Default to punyworld so the public link always opens with the intended style.
        const which = qs('tileset', 'punyworld');
        if (!which) return false;

        let png = './assets/tilesets/user.png';
        let json = './assets/tilesets/user.tileset.json';
        if (which === 'punyworld') {
            png = './assets/tilesets/punyworld.png';
            json = './assets/tilesets/punyworld.tileset.json';
        } else if (which === 'remote') {
            // Plug-and-play mode:
            // ?tileset=remote&tilesetPng=https://...png&tilesetJson=https://...json
            const qPng = normalizeUrl(qs('tilesetPng', ''));
            const qJson = normalizeUrl(qs('tilesetJson', ''));
            const sPng = normalizeUrl(localStorage.getItem('tilesetPng') || '');
            const sJson = normalizeUrl(localStorage.getItem('tilesetJson') || '');
            png = qPng || sPng;
            json = qJson || sJson;
            if (!png || !json) return false;
            try {
                localStorage.setItem('tilesetPng', png);
                localStorage.setItem('tilesetJson', json);
            } catch {}
        } else if (which !== 'external') {
            return false;
        }

        try {
            const cfgRes = await fetch(json, {cache: 'no-store'});
            if (!cfgRes.ok) return false;
            const cfg = await cfgRes.json();
            const img = new Image();
            img.crossOrigin = 'anonymous';
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
                img.src = png;
            });
            sprites.tileset = img;
            sprites.tilesetCfg = cfg;
            return true;
        } catch (e) {
            console.warn('External tileset load failed; using procedural.', e);
            return false;
        }
    }

    // Optional helper for DevTools:
    // setRemoteTileset('https://...png','https://...json')
    window.setRemoteTileset = function(pngUrl, jsonUrl) {
        try {
            const p = normalizeUrl(pngUrl);
            const j = normalizeUrl(jsonUrl);
            if (!p || !j) return false;
            localStorage.setItem('tilesetPng', p);
            localStorage.setItem('tilesetJson', j);
            location.href = `${location.origin}${location.pathname}?tileset=remote`;
            return true;
        } catch {
            return false;
        }
    };

    async function loadAssets() {
        const progress = document.getElementById('progressFill');
        const text = document.getElementById('loadingText');
        
        // Update totalSprites based on the new SPRITE_URLS
        const totalSprites = Object.keys(SPRITE_URLS).length;
        
        loadedCount = 0; // Reset loadedCount in case this function is called again

        // Tileset:
        // - default is procedural (stable + safe)
        // - optional external pack via ?tileset=external
        const loadedExternal = await tryLoadExternalTileset();
        if (!loadedExternal) {
            sprites.tileset = createTilesetCanvas();
            sprites.tilesetCfg = null;
        }

        // Load story in parallel; do not block asset loading.
        loadStory();

        for (const [name, url] of Object.entries(SPRITE_URLS)) {
            text.textContent = `Loading ${name}...`;
            try {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                await new Promise((resolve, reject) => {
                    img.onload = () => {
                        sprites[name] = img;
                        resolve();
                    };
                    img.onerror = () => {
                        console.warn(`Failed to load ${name} from ${url}. Using fallback.`);
                        // Fallback to a simple colored square or skip if no fallback
                        // For tilesets, we might want a default color, for sprites a placeholder
                        if (name.includes('Tiles')) { // Assume tilesets
                            sprites[name] = null; // Indicate failure, will draw colored tile
                        } else { // Assume sprites
                             const fallbackImg = document.createElement('canvas');
                             fallbackImg.width = 16; fallbackImg.height = 16;
                             const fctx = fallbackImg.getContext('2d');
                             fctx.fillStyle = 'red'; fctx.fillRect(0,0,16,16);
                             sprites[name] = fallbackImg;
                        }
                        resolve(); // Continue loading other assets
                    };
                    img.src = url;
                });
            } catch (e) {
                console.error(`Error loading ${name}:`, e);
                // Handle errors, e.g., set a placeholder or skip
                sprites[name] = null; 
            }
            loadedCount++;
            progress.style.width = (loadedCount / totalSprites * 100) + '%';
        }
        
        document.getElementById('loadingScreen').style.display = 'none';
        document.getElementById('titleScreen').style.display = 'flex';
        // Manga-accurate: Poliwhirl is Red's first Pokemon, not Pikachu!
        document.getElementById('titlePokemon').src = SPRITE_URLS.poliwhirl || ''; // Ensure src is valid
    }
    
    // ==================== DRAWING ====================
    function drawSprite(sprite, tx, ty, frame = 0, dir = 'down') {
        const dx = tx * ST;
        const dy = ty * ST;
        if (!sprite) {
            ctx.fillStyle = '#ef4444';
            ctx.fillRect(dx + 6, dy + 4, ST - 12, ST - 8);
            return;
        }

        // FRLG/NPC sheets are usually 16x32 (single frame), while player sheets can be 64x128 (4x4).
        const sw = sprite.naturalWidth || sprite.width || 0;
        const sh = sprite.naturalHeight || sprite.height || 0;
        if (sw <= 0 || sh <= 0) {
            ctx.fillStyle = '#ef4444';
            ctx.fillRect(dx + 6, dy + 4, ST - 12, ST - 8);
            return;
        }

        const dirIdx = {down: 0, left: 1, right: 2, up: 3}[dir] ?? 0;
        const isSheet = (sw >= 64 && sh >= 128);
        if (isSheet) {
            const f = Math.floor(frame) % 4;
            ctx.drawImage(sprite, f * 16, dirIdx * 32, 16, 32, dx, dy - (ST / 2), ST, ST * 1.5);
            return;
        }

        // Static NPC fallback (16x32 or single sprite).
        const srcH = (sh >= 32) ? 32 : sh;
        ctx.drawImage(sprite, 0, 0, Math.min(16, sw), srcH, dx, dy - (ST / 2), ST, ST * 1.5);
    }

    function drawFromAtlas(ax, ay, sx, sy) {
        ctx.drawImage(
            sprites.tileset,
            ax * TILE, ay * TILE,
            TILE, TILE,
            sx * ST, sy * ST,
            ST, ST
        );
    }

    function atlasFor(key, fallbackAx, fallbackAy) {
        const cfg = sprites.tilesetCfg;
        if (!cfg || !cfg.map) return {ax: fallbackAx, ay: fallbackAy};
        const v = cfg.map[key];
        if (!v || typeof v.ax !== 'number' || typeof v.ay !== 'number') return {ax: fallbackAx, ay: fallbackAy};
        return {ax: v.ax, ay: v.ay};
    }

    function noise01(mapId, x, y) {
        // Cheap deterministic hash -> [0,1)
        let h = 2166136261 >>> 0;
        const s = `${mapId}|${x}|${y}`;
        for (let i = 0; i < s.length; i++) {
            h ^= s.charCodeAt(i);
            h = Math.imul(h, 16777619) >>> 0;
        }
        return (h % 1000) / 1000;
    }

    function sameTile(map, x, y, tile) {
        if (!map) return false;
        if (x < 0 || y < 0 || x >= map.w || y >= map.h) return false;
        return map.data[y * map.w + x] === tile;
    }

    function drawEdgeLines(sx, sy, color, a, edgeMask) {
        // edgeMask: {t,b,l,r} booleans
        const x0 = sx * ST;
        const y0 = sy * ST;
        ctx.save();
        ctx.globalAlpha = a;
        ctx.fillStyle = color;
        const w = ST, h = ST;
        const t = 3; // thickness in pixels (scaled-space)
        if (edgeMask.t) ctx.fillRect(x0, y0, w, t);
        if (edgeMask.b) ctx.fillRect(x0, y0 + h - t, w, t);
        if (edgeMask.l) ctx.fillRect(x0, y0, t, h);
        if (edgeMask.r) ctx.fillRect(x0 + w - t, y0, t, h);
        ctx.restore();
    }

    function isBuildingTile(t) {
        return t === T.HOUSE_RED || t === T.HOUSE_BLUE || t === T.LAB;
    }

    function drawTile(tile, sx, sy, mx, my, map) {
        if (!sprites.tileset) {
            ctx.fillStyle = '#000';
            ctx.fillRect(sx * ST, sy * ST, ST, ST);
            return;
        }

        if (tile === T.GRASS) {
            const n = noise01(GS.map, mx, my);
            const a = atlasFor('GRASS', 0, 0);
            const a2 = atlasFor('GRASS_ALT', 1, 2);
            if (n < 0.22) drawFromAtlas(a2.ax, a2.ay, sx, sy);
            else drawFromAtlas(a.ax, a.ay, sx, sy);
            return;
        }
        if (tile === T.PATH) {
            const n = noise01(GS.map, mx, my);
            const a = atlasFor('PATH', 1, 0);
            const a2 = atlasFor('PATH_ALT', 2, 2);
            if (n < 0.18) drawFromAtlas(a2.ax, a2.ay, sx, sy);
            else drawFromAtlas(a.ax, a.ay, sx, sy);
            // Add subtle border where PATH touches GRASS (cheap autotile, FRLG-like).
            const edges = {
                t: !sameTile(map, mx, my - 1, T.PATH) && !sameTile(map, mx, my - 1, T.WARP),
                b: !sameTile(map, mx, my + 1, T.PATH) && !sameTile(map, mx, my + 1, T.WARP),
                l: !sameTile(map, mx - 1, my, T.PATH) && !sameTile(map, mx - 1, my, T.WARP),
                r: !sameTile(map, mx + 1, my, T.PATH) && !sameTile(map, mx + 1, my, T.WARP),
            };
            drawEdgeLines(sx, sy, 'rgba(0,0,0,0.22)', 1.0, edges);
            return;
        }
        if (tile === T.WATER) {
            const a = atlasFor('WATER', 2, 0);
            drawFromAtlas(a.ax, a.ay, sx, sy);
            // Shoreline hint when WATER touches non-water.
            const edges = {
                t: !sameTile(map, mx, my - 1, T.WATER),
                b: !sameTile(map, mx, my + 1, T.WATER),
                l: !sameTile(map, mx - 1, my, T.WATER),
                r: !sameTile(map, mx + 1, my, T.WATER),
            };
            drawEdgeLines(sx, sy, 'rgba(215,191,138,0.55)', 1.0, edges); // sand-ish
            return;
        }
        if (tile === T.TALL_GRASS) { const a = atlasFor('TALL_GRASS', 3, 0); drawFromAtlas(a.ax, a.ay, sx, sy); return; }
        if (tile === T.TREE) { const a = atlasFor('TREE', 4, 0); drawFromAtlas(a.ax, a.ay, sx, sy); return; }
        if (tile === T.FENCE) { const a = atlasFor('FENCE', 5, 0); drawFromAtlas(a.ax, a.ay, sx, sy); return; }
        if (tile === T.SIGN) { const a = atlasFor('SIGN', 6, 0); drawFromAtlas(a.ax, a.ay, sx, sy); return; }
        if (tile === T.FLOWER) { const a = atlasFor('FLOWER', 7, 0); drawFromAtlas(a.ax, a.ay, sx, sy); return; }
        if (tile === T.WARP) { const a = atlasFor('WARP', 0, 2); drawFromAtlas(a.ax, a.ay, sx, sy); return; }
        if (tile === T.NPC) { drawFromAtlas(0, 0, sx, sy); return; } // map marker only
        if (tile === T.FLOOR_IN) { const a = atlasFor('FLOOR_IN', 6, 1); drawFromAtlas(a.ax, a.ay, sx, sy); return; }
        if (tile === T.WALL_IN) { const a = atlasFor('WALL_IN', 7, 1); drawFromAtlas(a.ax, a.ay, sx, sy); return; }
        if (tile === T.TABLE) { const a = atlasFor('TABLE', 0, 3); drawFromAtlas(a.ax, a.ay, sx, sy); return; }
        if (tile === T.SHELF) { const a = atlasFor('SHELF', 1, 3); drawFromAtlas(a.ax, a.ay, sx, sy); return; }

        if (isBuildingTile(tile)) {
            const same = (x, y) => {
                if (x < 0 || y < 0 || x >= map.w || y >= map.h) return false;
                return map.data[y * map.w + x] === tile;
            };
            const top = !same(mx, my - 1);
            const bottom = !same(mx, my + 1);
            const leftEdge = !same(mx - 1, my);
            const rightEdge = !same(mx + 1, my);

            const roofKey = (tile === T.HOUSE_RED) ? 'ROOF_RED' : (tile === T.HOUSE_BLUE) ? 'ROOF_BLUE' : 'ROOF_LAB';
            const roofAxAy = atlasFor(roofKey, (tile === T.HOUSE_RED) ? 0 : (tile === T.HOUSE_BLUE) ? 1 : 2, 1);
            if (top) {
                drawFromAtlas(roofAxAy.ax, roofAxAy.ay, sx, sy);
                // subtle roof edge shade
                ctx.fillStyle = 'rgba(0,0,0,0.10)';
                if (leftEdge) ctx.fillRect(sx * ST, sy * ST, 3, ST);
                if (rightEdge) ctx.fillRect(sx * ST + ST - 3, sy * ST, 3, ST);
                return;
            }

            // base wall
            const wallAxAy = atlasFor('WALL', 3, 1);
            drawFromAtlas(wallAxAy.ax, wallAxAy.ay, sx, sy);

            // door on bottom row, center-ish
            if (bottom) {
                const doorCandidate = same(mx - 1, my) && same(mx + 1, my);
                if (doorCandidate) {
                    const doorAxAy = atlasFor('DOOR', 4, 1);
                    drawFromAtlas(doorAxAy.ax, doorAxAy.ay, sx, sy);
                    return;
                }
            }

            // window on mid walls
            if (!leftEdge && !rightEdge && !bottom) {
                if (((mx + my) % 4) === 0) {
                    const winAxAy = atlasFor('WINDOW', 5, 1);
                    drawFromAtlas(winAxAy.ax, winAxAy.ay, sx, sy);
                }
            }
            return;
        }

        // fallback
        ctx.fillStyle = '#000';
        ctx.fillRect(sx * ST, sy * ST, ST, ST);
    }

    function render() {
        const map = MAPS[GS.map];
        if (!map) return requestAnimationFrame(render);
        
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        const camX = Math.floor(GS.px - VW / 2);
        const camY = Math.floor(GS.py - VH / 2);
        
        // Draw tiles
        for (let sy = 0; sy < VH + 1; sy++) {
            for (let sx = 0; sx < VW + 1; sx++) {
                const mx = camX + sx;
                const my = camY + sy;
                if (mx >= 0 && mx < map.w && my >= 0 && my < map.h) {
                    const tile = map.data[my * map.w + mx];
                    drawTile(tile, sx, sy, mx, my, map);
                }
            }
        }
        
        // Draw NPCs
        if (map.npcs) {
            for (const npc of map.npcs) {
                const sx = npc.x - camX;
                const sy = npc.y - camY;
                if (sx >= -1 && sx <= VW && sy >= -1 && sy <= VH) {
                    drawSprite(sprites[npc.sprite], sx, sy, 0, 'down');
                }
            }
        }
        
        // Draw Pikachu follower
        if (GS.hasPikachu) {
            const psx = GS.px - camX - 1;
            const psy = GS.py - camY;
            if (sprites.pikachuOW && sprites.pikachuOW.complete) {
                ctx.drawImage(sprites.pikachuOW, 0, 0, 32, 32, psx * ST, psy * ST, ST, ST);
            } else {
                ctx.fillStyle = '#f8d030';
                ctx.fillRect(psx * ST + 4, psy * ST + 4, ST - 8, ST - 8);
            }
        }
        
        // Draw player
        const psx = GS.px - camX;
        const psy = GS.py - camY;
        drawSprite(sprites.red, psx, psy, animFrame, GS.dir);
        
        animFrame = (animFrame + 0.1) % 4;
        requestAnimationFrame(render);
    }
    
    // ==================== MOVEMENT ====================
    function canMove(x, y) {
        const map = MAPS[GS.map];
        if (!map || x < 0 || x >= map.w || y < 0 || y >= map.h) return false;
        const tile = map.data[y * map.w + x];
        if (SOLID.includes(tile)) return false;
        if (map.npcs) for (const n of map.npcs) if (n.x === x && n.y === y) return false;
        return true;
    }
    
    function move(dir) {
        if (dialog || inBattle) return;
        GS.dir = dir;
        let nx = GS.px, ny = GS.py;
        if (dir === 'up') ny--;
        else if (dir === 'down') ny++;
        else if (dir === 'left') nx--;
        else if (dir === 'right') nx++;
        
        if (canMove(nx, ny)) {
            GS.px = nx; GS.py = ny;
            checkWarp();
            checkEncounter();
        }
    }
    
    function startMove(dir) { move(dir); moveInt = setInterval(() => move(dir), 150); }
    function stopMove() { if (moveInt) { clearInterval(moveInt); moveInt = null; } }
    
    // ==================== WARPS ====================
    function checkWarp() {
        const map = MAPS[GS.map];
        if (!map || !map.warps) return;
        for (const w of map.warps) {
            if (GS.px === w.x && GS.py === w.y) {
                GS.map = w.to;
                GS.px = w.tx;
                GS.py = w.ty;
                onMapEnter(GS.map);
                break;
            }
        }
    }

    function tryAutoStoryBeat() {
        if (!GS.story) return false;
        if (activeBeatId || dialog || inBattle) return false;
        const mapId = GS.map;

        if (mapId === 'oak_lab' && GS.story.sawMew && !GS.story.gotSaur) {
            return playBeat('ch1_oak_mew_explain');
        }
        if (mapId === 'viridian' && !GS.story.visitedViridian) {
            GS.story.visitedViridian = true;
            return playBeat('ch1_viridian_arrival');
        }
        if (mapId === 'viridian_forest' && GS.story.gotSaur && !GS.story.forestBeat1) {
            GS.story.forestBeat1 = true;
            return playBeat('ch1_viridian_forest_first');
        }
        if (mapId === 'pewter' && !GS.story.visitedPewter) {
            GS.story.visitedPewter = true;
            return playBeat('ch1_pewter_arrival');
        }
        if (mapId === 'pewter' && GS.story.brockBattleDone && !GS.story.block_02_done) {
            return playBeat('ch2_depart_pewter');
        }
        if (mapId === 'route2' && GS.story.block_02_done && !GS.story.block_03_done) {
            return playBeat('ch2_mtmoon_entry');
        }
        if (mapId === 'mt_moon' && GS.story.block_03_done && !GS.story.block_04_done) {
            return playBeat('ch2_green_first_contact');
        }
        if (mapId === 'mt_moon' && GS.story.block_04_done && !GS.story.block_05_done) {
            return playBeat('ch2_rocket_grunt_cave');
        }
        if (mapId === 'mt_moon' && GS.story.block_05_done && !GS.story.block_06_done) {
            return playBeat('ch2_fossil_rumor');
        }
        if (mapId === 'cerulean' && GS.story.block_06_done && !GS.story.block_07_done) {
            return playBeat('ch3_cerulean_arrival');
        }
        if (mapId === 'cerulean' && GS.story.block_07_done && !GS.story.block_08_done) {
            return playBeat('ch3_misty_clash');
        }
        if (mapId === 'cerulean' && GS.story.block_08_done && !GS.story.block_09_done) {
            return playBeat('ch3_bill_event');
        }
        if (mapId === 'vermilion' && GS.story.block_09_done && !GS.story.block_10_done) {
            return playBeat('ch4_vermilion_setup');
        }
        if (mapId === 'vermilion' && GS.story.block_10_done && !GS.story.block_11_done) {
            return playBeat('ch4_ssanne_rocket');
        }
        if (mapId === 'vermilion' && GS.story.block_11_done && !GS.story.block_12_done) {
            return playBeat('ch5_surge_pressure');
        }
        if (mapId === 'lavender' && GS.story.block_12_done && !GS.story.block_13_done) {
            return playBeat('ch6_lavender_shadow');
        }
        if (mapId === 'silph_lobby' && GS.story.block_13_done && !GS.story.block_14_done) {
            return playBeat('ch7_silph_infiltration');
        }
        if (mapId === 'saffron' && GS.story.block_14_done && !GS.story.block_15_done) {
            return playBeat('ch8_saffron_psychic');
        }
        if (mapId === 'silph_lobby' && GS.story.block_15_done && !GS.story.block_16_done) {
            return playBeat('ch9_final_island_setup');
        }
        if (mapId === 'silph_lobby' && GS.story.block_16_done && !GS.story.block_17_done) {
            return playBeat('ch10_mewtwo_confront');
        }
        return false;
    }

    function onMapEnter(mapId) {
        // Lightweight, non-breaking story hooks. Real season script will live in beats/flags.
        if (!GS.story) GS.story = {};
        if (mapId === 'pewter_gym' && GS.story.caughtPika && !GS.story.brockBattleDone) {
            setTimeout(() => {
                showDialog('', [
                    '[ PEWTER GYM ]',
                    'BROCK observa em silencio do outro lado da arena.',
                    'A luta comeca quando voce falar com ele.'
                ]);
            }, 320);
        }
        setTimeout(() => { tryAutoStoryBeat(); }, 260);
    }
    
    // ==================== ENCOUNTERS ====================
    const GAME_MODE = {
        // When true: encounters/battles/captures/evolutions are driven by story beats (manga).
        // Random encounters are disabled to avoid grind and keep narrative control.
        storyLock: true,
        // When true and storyLock is false, allow tall grass RNG encounters.
        randomEncounters: true,
    };

    function checkEncounter() {
        const map = MAPS[GS.map];
        // Need Poliwhirl (or any team Pokemon) to battle
        if (!map || !map.enc || !GS.story.gotSaur || GS.team.length === 0) return;
        if (GAME_MODE.storyLock) return; // manga-driven only
        if (!GAME_MODE.randomEncounters) return;
        const tile = map.data[GS.py * map.w + GS.px];
        if (tile !== T.TALL_GRASS) return;
        if (Math.random() * 100 < map.enc.rate) {
            const roll = Math.random() * 100;
            let cum = 0;
            for (const p of map.enc.pokemon) {
                cum += p.rate;
                if (roll < cum) {
                    const lv = p.lv[0] + Math.floor(Math.random() * (p.lv[1] - p.lv[0] + 1));
                    startBattle({name: p.name, spr: p.spr, lv, hp: 10 + lv * 2, maxHp: 10 + lv * 2});
                    return;
                }
            }
        }
    }
    
    // ==================== BATTLE ====================
    // Get current active Pokemon (first healthy one in team)
    function getActivePokemon() {
        if (GS.team.length === 0) return GS.poli; // Fallback
        return GS.team[0]; // For now, first Pokemon
    }

    function setBattleLog(text) {
        document.getElementById('battleLog').textContent = text;
    }

    function showBattleOk(label = 'OK') {
        const btn = document.getElementById('battleOkBtn');
        btn.textContent = label;
        document.getElementById('battleOk').style.display = 'block';
    }

    function hideBattleOk() {
        document.getElementById('battleOk').style.display = 'none';
    }

    // Manga-first UX: battles are scripted, player only confirms (A/OK) to proceed.
    function battleWaitOk(label, fn) {
        battle.pending = fn;
        showBattleOk(label);
    }

    function battleOk() {
        if (!inBattle || !battle) return;
        if (!battle.pending) return;
        const fn = battle.pending;
        battle.pending = null;
        hideBattleOk();
        fn();
    }

    function battleScriptedStep() {
        if (!battle || !battle.scripted) return;
        const steps = battle.scriptSteps || [];
        if (battle.scriptIndex >= steps.length) {
            endBattle(true);
            return;
        }
        const step = steps[battle.scriptIndex++];

        if (step.type === 'log') {
            setBattleLog(step.text || '...');
            battleWaitOk('OK', () => battleScriptedStep());
            return;
        }

        if (step.type === 'playerMove') {
            const active = getActivePokemon();
            const moveName = step.move || 'Attack';
            const dmg = Math.max(0, step.damage ?? 0);
            setBattleLog(`${active.name || active.species} vai usar ${moveName}.`);
            battleWaitOk('OK', () => {
                // Apply
                battle.enemy.hp = Math.max(0, battle.enemy.hp - dmg);
                const pct = battle.enemy.hp / battle.enemy.maxHp * 100;
                const bar = document.getElementById('enemyHp');
                bar.style.width = pct + '%';
                bar.className = 'hp-fill' + (pct < 20 ? ' critical' : pct < 50 ? ' low' : '');
                setBattleLog(`${active.name || active.species} usou ${moveName}! ${dmg ? `${dmg} de dano!` : ''}`.trim());
                if (battle.enemy.hp <= 0) { setTimeout(() => endBattle(true), 700); return; }
                setTimeout(() => battleScriptedStep(), 500);
            });
            return;
        }

        if (step.type === 'enemyMove') {
            const active = getActivePokemon();
            const moveName = step.move || 'Attack';
            const dmg = Math.max(0, step.damage ?? 0);
            setBattleLog(`${battle.enemy.name} vai atacar.`);
            battleWaitOk('OK', () => {
                active.hp = Math.max(0, active.hp - dmg);
                updatePlayerHp();
                setBattleLog(`${battle.enemy.name} usou ${moveName}! ${dmg ? `${dmg} de dano!` : ''}`.trim());
                if (active.hp <= 0) { setTimeout(() => endBattle(false), 700); return; }
                setTimeout(() => battleScriptedStep(), 500);
            });
            return;
        }

        if (step.type === 'usePotion') {
            const active = getActivePokemon();
            const heal = Math.max(0, step.heal ?? 20);
            setBattleLog(`Usar POTION em ${active.name || active.species}?`);
            battleWaitOk('OK', () => {
                if (GS.items.potion > 0) GS.items.potion--;
                active.hp = Math.min(active.maxHp, active.hp + heal);
                updatePlayerHp();
                setBattleLog(`POTION! +${heal} HP.`);
                setTimeout(() => battleScriptedStep(), 500);
            });
            return;
        }

        if (step.type === 'capture') {
            // Capture is story-driven. We only show it and advance.
            const who = step.who || battle.enemy.name;
            setBattleLog(`Tentar capturar ${who}.`);
            battleWaitOk('OK', () => {
                setBattleLog(`${who} foi capturado!`);
                // Hook: caller can set flags/team in onCapture
                if (battle.onCapture) battle.onCapture(who);
                setTimeout(() => battleScriptedStep(), 500);
            });
            return;
        }

        if (step.type === 'end') {
            endBattle(!!step.won);
            return;
        }

        // Unknown step: skip safely
        battleScriptedStep();
    }
    
    function startBattle(enemy, opts = {}) {
        inBattle = true;
        const active = getActivePokemon();
        battle = {
            enemy,
            turn: 'player',
            active,
            scripted: !!opts.scripted || (GAME_MODE.storyLock && opts.scripted !== false),
            scriptSteps: Array.isArray(opts.scriptSteps) ? opts.scriptSteps : null,
            scriptIndex: 0,
            pending: null,
            onEnd: typeof opts.onEnd === 'function' ? opts.onEnd : null,
            onCapture: typeof opts.onCapture === 'function' ? opts.onCapture : null,
        };
        
        document.getElementById('enemyName').textContent = enemy.name;
        document.getElementById('enemyLevel').textContent = 'Lv. ' + enemy.lv;
        document.getElementById('enemySprite').src = SPRITE_URLS[enemy.spr] || '';
        document.getElementById('enemyHp').style.width = '100%';
        
        // Use active team Pokemon (Poliwhirl to start)
        document.getElementById('playerName').textContent = active.name || active.species;
        document.getElementById('playerLevel').textContent = 'Lv. ' + active.lv;
        // Try back sprite, fallback to front
        const backSprite = SPRITE_URLS[active.species?.toLowerCase() + 'Back'] || 
                          SPRITE_URLS.poliwhirlBack;
        document.getElementById('playerSprite').src = backSprite;
        updatePlayerHp();
        
        setBattleLog(`Wild ${enemy.name} appeared!`);
        document.getElementById('battleScreen').style.display = 'flex';
        document.getElementById('movesMenu').style.display = 'none';
        hideBattleOk();

        if (battle.scripted) {
            // In manga-first mode, hide menus and run the script.
            document.getElementById('battleMenu').style.display = 'none';
            // Default scripted flow if caller didn't pass steps (safe minimal fight).
            if (!battle.scriptSteps) {
                battle.scriptSteps = [
                    {type: 'log', text: `Um ${enemy.name} selvagem apareceu!`},
                    {type: 'playerMove', move: 'Water Gun', damage: 6},
                    {type: 'enemyMove', move: 'Tackle', damage: 3},
                    {type: 'playerMove', move: 'Water Gun', damage: 999},
                    {type: 'end', won: true},
                ];
            }
            battle.scriptIndex = 0;
            battleScriptedStep();
        } else {
            document.getElementById('battleMenu').style.display = 'grid';
            buildMoves();
        }
    }
    
    function updatePlayerHp() {
        const active = getActivePokemon();
        const pct = active.hp / active.maxHp * 100;
        const bar = document.getElementById('playerHp');
        bar.style.width = pct + '%';
        bar.className = 'hp-fill' + (pct < 20 ? ' critical' : pct < 50 ? ' low' : '');
        document.getElementById('playerCurrentHp').textContent = active.hp;
        document.getElementById('playerMaxHp').textContent = active.maxHp;
    }
    
    // Poliwhirl's moves (manga-accurate)
    const POLI_MOVES = [
        {name: 'Water Gun', type: 'water', pow: 40},
        {name: 'Double Slap', type: 'normal', pow: 35},
        {name: 'Hypnosis', type: 'psychic', pow: 0},
        {name: 'Bubble Beam', type: 'water', pow: 65}
    ];
    
    const MOVES = POLI_MOVES; // Default moves (will be dynamic later)
    
    function buildMoves() {
        const grid = document.getElementById('movesGrid');
        grid.innerHTML = '';
        for (const m of MOVES) {
            const btn = document.createElement('button');
            btn.className = `move-btn type-${m.type}`;
            btn.innerHTML = `<div class="move-name">${m.name}</div>`;
            btn.onclick = () => useMove(m);
            grid.appendChild(btn);
        }
    }
    
    function showMoves() {
        document.getElementById('battleMenu').style.display = 'none';
        document.getElementById('movesMenu').style.display = 'block';
    }
    
    function hideMoves() {
        document.getElementById('movesMenu').style.display = 'none';
        document.getElementById('battleMenu').style.display = 'grid';
    }
    
    function useMove(m) {
        if (battle.turn !== 'player') return;
        battle.turn = 'enemy';
        
        const active = getActivePokemon();
        let dmg = 0;
        if (m.pow > 0) {
            dmg = Math.floor((m.pow * active.lv / 50) + 2 + Math.random() * 5);
            // Type effectiveness
            if (m.type === 'water' && ['GEODUDE', 'ONIX', 'RHYHORN'].includes(battle.enemy.name)) dmg *= 2;
            if (m.type === 'electric' && battle.enemy.name === 'PIDGEY') dmg *= 2;
        }
        
        battle.enemy.hp = Math.max(0, battle.enemy.hp - dmg);
        const pct = battle.enemy.hp / battle.enemy.maxHp * 100;
        const bar = document.getElementById('enemyHp');
        bar.style.width = pct + '%';
        bar.className = 'hp-fill' + (pct < 20 ? ' critical' : pct < 50 ? ' low' : '');
        
        const pokeName = active.name || active.species;
        document.getElementById('battleLog').textContent = `${pokeName} used ${m.name}!${dmg ? ` ${dmg} damage!` : ''}`;
        
        if (battle.enemy.hp <= 0) { setTimeout(() => endBattle(true), 1000); return; }
        setTimeout(enemyTurn, 1500);
    }
    
    function enemyTurn() {
        const active = getActivePokemon();
        const dmg = Math.floor((30 * battle.enemy.lv / 50) + 2 + Math.random() * 3);
        active.hp = Math.max(0, active.hp - dmg);
        updatePlayerHp();
        document.getElementById('battleLog').textContent = `${battle.enemy.name} attacked! ${dmg} damage!`;
        if (active.hp <= 0) { setTimeout(() => endBattle(false), 1000); return; }
        battle.turn = 'player';
        hideMoves();
    }
    
    function endBattle(won) {
        const active = getActivePokemon();
        const pokeName = active.name || active.species;
        
        if (won) {
            if (!GAME_MODE.storyLock) {
                const exp = battle.enemy.lv * 10;
                active.exp += exp;
                if (active.exp >= active.lv * 50) {
                    active.lv++;
                    active.exp = 0;
                    active.maxHp += 2;
                    active.hp = active.maxHp;
                    document.getElementById('battleLog').textContent = `${pokeName} grew to Lv.${active.lv}!`;
                } else {
                    document.getElementById('battleLog').textContent = `Gained ${exp} EXP!`;
                }
            } else {
                // In storyLock mode, leveling is cosmetic and scripted by story beats.
                document.getElementById('battleLog').textContent = `Victory!`;
            }
        } else {
            document.getElementById('battleLog').textContent = `${pokeName} fainted...`;
            active.hp = Math.floor(active.maxHp / 2);
        }
        setTimeout(() => {
            document.getElementById('battleScreen').style.display = 'none';
            inBattle = false;
            const onEnd = battle && battle.onEnd ? battle.onEnd : null;
            const wonFinal = won;
            battle = null;
            saveGame();
            if (onEnd) onEnd(wonFinal);
        }, 2000);
    }
    
    function tryRun() {
        if (GAME_MODE.storyLock) {
            document.getElementById('battleLog').textContent = "Can't escape!";
            setTimeout(enemyTurn, 1000);
            return;
        }
        if (Math.random() < 0.7) {
            document.getElementById('battleLog').textContent = 'Got away safely!';
            setTimeout(() => {
                document.getElementById('battleScreen').style.display = 'none';
                inBattle = false;
                battle = null;
            }, 1000);
        } else {
            document.getElementById('battleLog').textContent = "Can't escape!";
            setTimeout(enemyTurn, 1000);
        }
    }
    
    function useBag() {
        const active = getActivePokemon();
        if (GS.items.potion > 0 && active.hp < active.maxHp) {
            GS.items.potion--;
            active.hp = Math.min(active.maxHp, active.hp + 20);
            document.getElementById('battleLog').textContent = 'Used POTION! +20 HP!';
            updatePlayerHp();
            setTimeout(enemyTurn, 1500);
        } else {
            document.getElementById('battleLog').textContent = GS.items.potion > 0 ? 'HP is full!' : 'No potions!';
        }
    }
    
    function showPokemon() {
        const active = getActivePokemon();
        const pokeName = active.name || active.species;
        document.getElementById('battleLog').textContent = `${pokeName} Lv.${active.lv} HP:${active.hp}/${active.maxHp}`;
    }
    
    // ==================== DIALOG ====================
    function showDialog(speaker, texts, cb) {
        dialogQ = texts.slice();
        dialog = {speaker, cb};
        nextDialog();
    }
    
    function nextDialog() {
        if (dialogQ.length === 0) {
            document.getElementById('dialogBox').style.display = 'none';
            document.getElementById('tapOverlay').style.display = 'none';
            // Important: clear dialog state BEFORE invoking cb.
            // Story runner chains many dialog actions; the callback commonly opens the next dialog.
            // If we null-out after cb, we can wipe the newly opened dialog and "freeze" on iPad.
            const cb = dialog && dialog.cb ? dialog.cb : null;
            dialog = null;
            dialogQ = [];
            if (cb) cb();
            return;
        }
        const box = document.getElementById('dialogBox');
        box.querySelector('.speaker').textContent = dialog.speaker;
        box.querySelector('.text').textContent = dialogQ.shift();
        box.style.display = 'block';
        document.getElementById('tapOverlay').style.display = 'block';
    }
    
    // ==================== INPUT ====================
    // Get dynamic dialog for NPCs based on story state
    function getDynamicDialog(npc) {
        // Blue's dialog changes based on story
        if (npc.name === 'Blue') {
            if (!GS.story.sawMew) {
                return [
                    '...Ah. Voce, RED.',
                    'Ainda se gabando de ser um grande treinador?',
                    'Esse seu POLIWHIRL e a unica coisa que voce tem.',
                    'Me chama quando conseguir capturar algo de verdade.'
                ];
            } else if (!GS.story.gotSaur) {
                return [
                    '...Voce viu aquela luz estranha tambem?',
                    'O velho esta obcecado com isso.',
                    'Um papo de POKeMON lendario...',
                    'Seja o que for, eu vou capturar antes de voce.'
                ];
            } else if (!GS.story.metBlue) {
                GS.story.metBlue = true;
                return [
                    'Entao o velho te deu um BULBASAUR? Grande coisa.',
                    'Ele me deu um CHARMANDER. Muito mais forte.',
                    'Eu sou o BLUE. Eu treino POKeMON para vencer.',
                    'Vamos ver quem e o verdadeiro melhor.',
                    '...Ate mais, RED.'
                ];
            } else {
                return [
                    'O que foi agora? Ainda por aqui?',
                    'Eu ja estou na frente. Como sempre.',
                    'Ate mais.'
                ];
            }
        }
        
        // Girl NPC
        if (npc.name === 'Girl') {
            if (!GS.story.sawMew) {
                return [
                    'Bem-vindo a PALLET TOWN!',
                    'Esse RED vive se gabando...',
                    '"Vou ser o maior treinador!"',
                    'Mas ele so tem um POKeMON!'
                ];
            } else if (!GS.story.gotSaur) {
                return [
                    'Voce viu aquela luz na floresta?!',
                    'O Professor OAK disse que pode ser o MEW!',
                    'Tomara que nao seja perigoso...'
                ];
            } else {
                return [
                    'Uau, o professor te deu um BULBASAUR!',
                    'Voce e o BLUE agora sao treinadores!',
                    'Ouvi dizer que a TEAM ROCKET foi vista ao norte...',
                    'Eles capturam POKeMON raros para coisas horriveis!'
                ];
            }
        }
        
        // Mom
        if (npc.name === 'Mom') {
            if (!GS.story.sawMew) {
                return [
                    'RED, pare de se gabar para as outras criancas!',
                    'Eu sei que voce criou o POLI sozinho, mas...',
                    'Talvez o Professor OAK te ensine um pouco de humildade.'
                ];
            } else if (!GS.story.gotSaur) {
                return [
                    'RED! O Professor OAK estava te procurando!',
                    'Ele disse que viu aquela luz na floresta tambem!',
                    'Vá ao laboratorio, rapido!'
                ];
            } else {
                return [
                    'Meu RED... agora um treinador de POKeMON de verdade.',
                    'POLI e SAUR tem sorte de ter voce.',
                    'Tome cuidado la fora... e apareca de vez em quando.'
                ];
            }
        }
        
        // Daisy (Blue's sister)
        if (npc.name === 'Daisy') {
            if (!GS.story.gotSaur) {
                return [
                    'Procurando o BLUE? Ele foi ao laboratorio do vovo.',
                    'Ele estava todo animado... o vovo deu um POKeMON a ele.',
                    'Um CHARMANDER, eu acho...'
                ];
            } else {
                return [
                    'Entao o vovo te deu um POKeMON tambem!',
                    'O BLUE passou aqui se gabando do CHARMANDER.',
                    'Voces dois sempre foram rivais, ne?'
                ];
            }
        }
        
        // Prof Oak (when talked to directly via handleA)
        if (npc.name === 'Prof. Oak') {
            if (!GS.story.sawMew) {
                return [
                    'Ah, RED! Entre, entre!',
                    'Voce notou algo estranho na floresta ultimamente?',
                    'Tenho registrado leituras de energia... incomuns.'
                ];
            } else if (!GS.story.gotSaur) {
                // This shouldn't happen often - warp handles it
                return [
                    'RED! Ainda bem que veio. Preciso te mostrar algo!'
                ];
            } else {
                return [
                    'Como o POLI esta?',
                    'Lembre: a POKeDEX registra dados automaticamente.',
                    'VIRIDIAN CITY fica ao norte. E um bom primeiro destino.',
                    'Mas tenha cuidado... ja vi sinais da TEAM ROCKET pela area.'
                ];
            }
        }

        if (npc.name === 'Brock') {
            if (!GS.story.caughtPika) {
                return [
                    'Voce parece ter pressa, RED.',
                    'Antes de pensar em desafios maiores...',
                    'Proteja os POKeMON desta cidade.'
                ];
            }
            if (!GS.story.brockBattleDone) {
                return [
                    'Entao foi voce quem enfrentou a TEAM ROCKET.',
                    'Mostre sua determinacao no campo.',
                    'Eu, BROCK, vou testar sua base de treinador.'
                ];
            }
            return [
                'Seu elo com POLI, SAUR e PIKA esta mais forte.',
                'Continue. A jornada em KANTO so comecou.'
            ];
        }
        
        // Default: return static dialog if exists
        return npc.dialog || ['...'];
    }
    
    function handleA() {
        if (inBattle && battle && battle.pending) { battleOk(); return; }
        if (dialog) { nextDialog(); return; }
        const map = MAPS[GS.map];
        if (!map) return;
        let tx = GS.px, ty = GS.py;
        if (GS.dir === 'up') ty--;
        else if (GS.dir === 'down') ty++;
        else if (GS.dir === 'left') tx--;
        else if (GS.dir === 'right') tx++;

        // Sign interaction (tile-based)
        if (tx >= 0 && ty >= 0 && tx < map.w && ty < map.h) {
            const t = map.data[ty * map.w + tx];
            if (t === T.SIGN) {
                handleSign(GS.map, tx, ty);
                return;
            }
        }

        if (!map.npcs) return;
        for (const n of map.npcs) {
            if (n.x === tx && n.y === ty) {
                if (n.name === 'Brock' && GS.story.caughtPika && !GS.story.brockBattleDone) {
                    if (playBeat('ch1_brock_intro')) return;
                }
                const dynamicDialog = getDynamicDialog(n);
                showDialog(n.name, dynamicDialog);
                return;
            }
        }
    }

    function handleSign(mapId, x, y) {
        if (mapId === 'pallet_town') {
            showDialog('', [
                'PALLET TOWN',
                'Uma cidade pequena, mas cheia de sonhos.'
            ]);
            return;
        }
        if (mapId === 'viridian') {
            showDialog('', [
                'VIRIDIAN CITY',
                'O GINASIO esta fechado.'
            ]);
            return;
        }
        if (mapId === 'pewter') {
            showDialog('', [
                'PEWTER CITY',
                'A cidade das rochas.'
            ]);
            return;
        }
        showDialog('', ['...']);
    }
    
    function handleB() {}

    function dbg(msg) {
        const bar = document.getElementById('debugBar');
        if (!bar) return;
        if (bar.style.display !== 'block') return;
        bar.textContent = String(msg || '');
    }

    function enableDebugIfNeeded() {
        const bar = document.getElementById('debugBar');
        if (!bar) return;
        const enabled = (new URLSearchParams(location.search)).get('debug') === '1';
        if (enabled) bar.style.display = 'block';
    }

    enableDebugIfNeeded();
    window.addEventListener('error', (e) => {
        dbg(`ERROR: ${e.message || e.type || 'unknown'} @ ${e.filename || ''}:${e.lineno || ''}`);
    });
    window.addEventListener('unhandledrejection', (e) => {
        dbg(`PROMISE: ${e.reason ? (e.reason.message || String(e.reason)) : 'unknown'}`);
    });

    let lastTapAt = 0;
    function tapAdvance(e) {
        try {
            const now = Date.now();
            // iOS often fires touchstart + click; debounce to avoid double-advancing.
            if (now - lastTapAt < 120) return;
            lastTapAt = now;

            if (e && typeof e.preventDefault === 'function') e.preventDefault();
            if (e && typeof e.stopPropagation === 'function') e.stopPropagation();
            dbg(`tapAdvance: dialog=${!!dialog} q=${Array.isArray(dialogQ) ? dialogQ.length : 'NA'} map=${GS.map}`);
            // Fail-safe: when a dialog is open, advance it directly (do not route through handleA()).
            if (inBattle && battle && battle.pending) { battleOk(); return; }
            if (dialog) { nextDialog(); return; }
            handleA();
        } catch (err) {
            dbg(`tapAdvance threw: ${err && err.message ? err.message : String(err)}`);
            // Fail open: clear dialog state so the game doesn't brick.
            dialog = null;
            dialogQ = [];
            const box = document.getElementById('dialogBox');
            if (box) box.style.display = 'none';
            const ov = document.getElementById('tapOverlay');
            if (ov) ov.style.display = 'none';
        }
    }

    const tapOverlayEl = document.getElementById('tapOverlay');
    const dialogBoxEl = document.getElementById('dialogBox');
    // Multiple event types for maximum iPad Safari compatibility.
    tapOverlayEl.addEventListener('pointerdown', tapAdvance);
    tapOverlayEl.addEventListener('click', tapAdvance);
    tapOverlayEl.addEventListener('touchstart', tapAdvance, {passive: false});
    dialogBoxEl.addEventListener('pointerdown', tapAdvance);
    dialogBoxEl.addEventListener('click', tapAdvance);
    dialogBoxEl.addEventListener('touchstart', tapAdvance, {passive: false});

    // iPad fallback: tapping the canvas advances dialog / scripted battle.
    canvas.addEventListener('pointerdown', tapAdvance);
    canvas.addEventListener('click', tapAdvance);
    canvas.addEventListener('touchstart', tapAdvance, {passive: false});
    
    document.addEventListener('keydown', e => {
        if (e.key === 'ArrowUp' || e.key === 'w') move('up');
        else if (e.key === 'ArrowDown' || e.key === 's') move('down');
        else if (e.key === 'ArrowLeft' || e.key === 'a') move('left');
        else if (e.key === 'ArrowRight' || e.key === 'd') move('right');
        else if (e.key === 'Enter' || e.key === 'z' || e.key === 'x') handleA();
    });
    
    // ==================== SAVE/LOAD ====================
    function saveGame() { localStorage.setItem('pokemon_adv', JSON.stringify(GS)); }
    function migrateSave(gs) {
        if (!gs || typeof gs !== 'object') return gs;
        if (!gs.story || typeof gs.story !== 'object') gs.story = {};
        if (typeof gs.story.chapter !== 'number') gs.story.chapter = 1;
        if (typeof gs.story.season !== 'number') gs.story.season = 1;
        if (typeof gs.story.beat !== 'string') gs.story.beat = 'ch1_intro';
        if (typeof gs.story.visitedViridian !== 'boolean') gs.story.visitedViridian = false;
        if (typeof gs.story.visitedPewter !== 'boolean') gs.story.visitedPewter = false;
        if (typeof gs.story.caughtPika !== 'boolean') gs.story.caughtPika = false;
        if (typeof gs.story.brockBattleDone !== 'boolean') gs.story.brockBattleDone = false;
        if (!Array.isArray(gs.team)) gs.team = [];
        if (!gs.items) gs.items = {potion: 0, pokeball: 0};
        if (!gs.poli) gs.poli = {name: 'POLI', species: 'POLIWHIRL', hp: 28, maxHp: 28, lv: 8, exp: 0};
        if (!gs.saur) gs.saur = {name: 'SAUR', species: 'BULBASAUR', hp: 22, maxHp: 22, lv: 5, exp: 0};
        if (!gs.pika) gs.pika = {name: 'PIKA', species: 'PIKACHU', hp: 20, maxHp: 20, lv: 6, exp: 0};
        return gs;
    }
    function loadGame() {
        const s = localStorage.getItem('pokemon_adv');
        if (s) {
            GS = migrateSave(JSON.parse(s));
            // Defensive reset for stale runtime flags from previous sessions.
            dialog = null;
            dialogQ = [];
            inBattle = false;
            battle = null;
            activeBeatId = null;
            const dialogBox = document.getElementById('dialogBox');
            const tapOverlay = document.getElementById('tapOverlay');
            const battleScreen = document.getElementById('battleScreen');
            if (dialogBox) dialogBox.style.display = 'none';
            if (tapOverlay) tapOverlay.style.display = 'none';
            if (battleScreen) battleScreen.style.display = 'none';
            document.getElementById('titleScreen').style.display = 'none';
            onMapEnter(GS.map);
            render();
        }
        else alert('No save found!');
    }
    
    function startNewGame() {
        // Hard reset runtime state to avoid post-cutscene soft-locks.
        dialog = null;
        dialogQ = [];
        inBattle = false;
        battle = null;
        activeBeatId = null;
        const dialogBox = document.getElementById('dialogBox');
        const tapOverlay = document.getElementById('tapOverlay');
        const battleScreen = document.getElementById('battleScreen');
        if (dialogBox) dialogBox.style.display = 'none';
        if (tapOverlay) tapOverlay.style.display = 'none';
        if (battleScreen) battleScreen.style.display = 'none';

        // MANGA-ACCURATE GAME STATE (Pokémon Adventures)
        GS = {
            px: 10, py: 10, dir: 'down', map: 'pallet_town',
            // Story progression (MANGA ACCURATE)
            story: {
                season: 1,
                beat: 'ch1_intro',
                chapter: 1,           // Ch1: VS Mew
                sawMew: false,        // Saw Mew in forest
                talkedToOak: false,   // First talk with Oak
                gotPokedex: false,    // Received Pokedex
                gotSaur: false,       // Received Bulbasaur from Oak
                metBlue: false,       // Met rival Blue
                defeatedBlue1: false, // First battle vs Blue
                metGreen: false,      // Met Green (the thief girl)
                caughtPika: false,    // Pewter rescue arc
                brockBattleDone: false,
            },
            // MANGA ACCURATE: Red already has POLI before the story starts!
            // Poli was Red's first Pokemon that he raised from a Poliwag
            team: [],
            // Red's Pokemon (manga names)
            poli: {name: 'POLI', species: 'POLIWHIRL', hp: 28, maxHp: 28, lv: 8, exp: 0},
            saur: {name: 'SAUR', species: 'BULBASAUR', hp: 22, maxHp: 22, lv: 5, exp: 0},
            pika: {name: 'PIKA', species: 'PIKACHU', hp: 20, maxHp: 20, lv: 6, exp: 0},
            items: {potion: 3, pokeball: 5},
            badges: 0
        };
        
        document.getElementById('titleScreen').style.display = 'none';
        
        setTimeout(() => {
            // Manga-first: run story beat from external script (fallback is the old inline flow).
            if (!playBeat('ch1_intro')) {
                // If story JSON didn't load yet, keep legacy flow (avoid blank screen).
                showDialog('', [
                    'PALLET TOWN - Uma pequena cidade na regiao de KANTO.',
                    'Aqui vive um garoto que vive se gabando de ser um grande treinador...',
                    'O nome dele e RED.'
                ]);
            }
        }, 500);
        render();
    }
    
    setInterval(saveGame, 30000);
    
    // Start loading
    loadAssets();
    </script>
</body>
</html>
