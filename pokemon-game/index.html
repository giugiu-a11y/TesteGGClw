<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pokémon Adventures - Red Chapter</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { 
            width: 100%; height: 100%; 
            background: #000; 
            overflow: hidden; 
            font-family: 'Press Start 2P', monospace;
        }
        
        #loadingScreen {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: #000; color: #fff;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 9999; font-size: 12px;
        }
        
        #loadingScreen .progress {
            width: 200px; height: 20px;
            background: #333; border: 2px solid #fff;
            margin-top: 20px;
        }
        
        #loadingScreen .progress-fill {
            height: 100%; background: #4ade80;
            width: 0%; transition: width 0.3s;
        }
        
        #gameContainer {
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            width: 100%; height: 100%;
            background: linear-gradient(180deg, #a6d07c 0%, #7db35a 100%);
        }
        
        canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            border: 4px solid #2e3f2d;
            border-radius: 3px;
            box-shadow: 0 0 0 3px #c8d8aa, 0 10px 0 rgba(0,0,0,0.25);
        }
        
        .controls {
            position: fixed; bottom: 10px; left: 0; right: 0;
            display: flex; justify-content: space-between;
            padding: 0 15px; z-index: 1000;
        }
        
        .dpad {
            display: grid;
            grid-template: repeat(3, 36px) / repeat(3, 36px);
            gap: 2px;
        }
        
        .dpad button {
            background: rgba(50, 50, 70, 0.9);
            border: 2px solid #666;
            color: #fff;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .dpad button:active { background: #e63946; }
        .dpad .up { grid-column: 2; grid-row: 1; }
        .dpad .left { grid-column: 1; grid-row: 2; }
        .dpad .right { grid-column: 3; grid-row: 2; }
        .dpad .down { grid-column: 2; grid-row: 3; }
        
        .action-buttons { display: flex; gap: 8px; align-items: flex-end; }
        
        .action-buttons button {
            width: 50px; height: 50px;
            border-radius: 50%;
            font-size: 12px; font-weight: bold;
            border: 3px solid;
            cursor: pointer;
            font-family: inherit;
        }
        
        .btn-a { background: #c84b4b; border-color: #923636; color: white; }
        .btn-b { background: #4b6fb0; border-color: #355286; color: white; }
        
        /* FRLG-ish message box */
        #dialogBox {
            display: none;
            position: fixed;
            bottom: 100px; left: 50%;
            transform: translateX(-50%);
            width: 90%; max-width: 480px;
            background: #f7f3e8;
            border: 4px solid #1f2a44;
            border-radius: 8px;
            padding: 12px;
            font-size: 11px;
            line-height: 1.8;
            z-index: 2000;
            box-shadow: 0 10px 0 rgba(0,0,0,0.35);
        }

        /* Captures taps anywhere to advance dialog on iPad */
        #tapOverlay {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 1500;
            background: transparent;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        /* Debug (enable with ?debug=1) */
        #debugBar {
            display: none;
            position: fixed;
            top: 6px;
            left: 6px;
            z-index: 9000;
            background: rgba(0,0,0,0.75);
            color: #fff;
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 9px;
            line-height: 1.35;
            max-width: 90vw;
            word-break: break-word;
        }

        #mapBanner {
            display: none;
            position: fixed;
            top: 14px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2600;
            background: rgba(15, 23, 42, 0.92);
            color: #f8fafc;
            border: 3px solid #cbd5e1;
            border-radius: 10px;
            padding: 8px 12px;
            font-size: 9px;
            box-shadow: 0 6px 0 rgba(0,0,0,0.25);
            letter-spacing: 0.3px;
            text-align: center;
            min-width: 180px;
        }

        #sceneBackdrop {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 1200;
            background-size: cover;
            background-position: center center;
            background-repeat: no-repeat;
            opacity: 0.45;
            pointer-events: none;
            filter: saturate(1.1) contrast(1.04);
        }
        #dialogBox .dialog-content {
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        #dialogBox .text-wrap {
            flex: 1;
            min-width: 0;
        }

        #dialogBox .portrait {
            display: none;
            width: 56px;
            height: 56px;
            object-fit: contain;
            image-rendering: pixelated;
            background: #fff;
            border: 2px solid #1f2a44;
            border-radius: 6px;
            padding: 2px;
            flex: 0 0 auto;
        }

        #dialogBox .speaker {
            font-weight: bold; color: #1f2a44;
            margin-bottom: 6px; font-size: 10px;
        }
        
        #dialogBox .text { color: #1b1b1b; }
        #dialogBox .continue { 
            text-align: right; font-size: 8px; 
            color: #666; margin-top: 8px;
            animation: blink 1s infinite;
            background-position: left center;
            background-repeat: no-repeat;
            background-size: 12px 12px;
            padding-left: 14px;
        }
        
        @keyframes blink { 50% { opacity: 0; } }
        @keyframes evolve-flash {
            0% { filter: brightness(1); }
            25% { filter: brightness(3) saturate(0); }
            50% { filter: brightness(5) saturate(0); }
            75% { filter: brightness(3) saturate(0); }
            100% { filter: brightness(1); }
        }
        .evolving { animation: evolve-flash 1.5s ease-in-out; }
        .evolution-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: white; opacity: 0; pointer-events: none;
            transition: opacity 0.3s;
            z-index: 9999;
        }
        .evolution-overlay.active { opacity: 0.9; }
        
        #battleScreen {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(180deg, #87ceeb 0%, #98d8aa 100%);
            z-index: 3000;
            flex-direction: column;
        }
        
        .battle-field {
            flex: 1; display: flex; flex-direction: column;
            justify-content: space-around; padding: 15px;
            background-size: cover;
            background-position: center center;
            background-repeat: no-repeat;
        }
        
        .pokemon-slot {
            display: flex; align-items: center; gap: 15px;
        }
        
        .enemy-slot { justify-content: flex-end; }
        .player-slot { justify-content: flex-start; }
        
        .pokemon-sprite {
            width: 80px; height: 80px;
            image-rendering: pixelated;
        }

        .trainer-portrait {
            width: 72px; height: 72px;
            image-rendering: pixelated;
            border: 2px solid rgba(0,0,0,0.45);
            border-radius: 6px;
            background: rgba(255,255,255,0.85);
            padding: 2px;
        }
        
        .pokemon-info {
            background: #fff;
            border: 3px solid #333;
            border-radius: 8px;
            padding: 8px 12px;
            min-width: 150px;
            box-shadow: inset 0 0 0 2px rgba(255,255,255,0.45);
        }
        
        .pokemon-name { font-size: 11px; font-weight: bold; }
        .pokemon-level { font-size: 9px; color: #666; }
        
        .hp-bar {
            height: 6px; background: #333;
            border-radius: 3px; margin-top: 4px;
        }
        
        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #22c55e);
            transition: width 0.3s;
            border-radius: 3px;
        }
        
        .hp-fill.low { background: linear-gradient(90deg, #fbbf24, #f59e0b); }
        .hp-fill.critical { background: linear-gradient(90deg, #ef4444, #dc2626); }
        
        .battle-menu {
            background: #fff;
            border-top: 4px solid #333;
            padding: 12px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .battle-menu button {
            padding: 12px;
            font-size: 11px;
            font-family: inherit;
            border: 3px solid #333;
            border-radius: 6px;
            cursor: pointer;
        }
        
        .battle-menu .fight { background: #ef4444; color: white; }
        .battle-menu .bag { background: #f59e0b; color: white; }
        .battle-menu .pokemon { background: #22c55e; color: white; }
        .battle-menu .run { background: #64748b; color: white; }
        
        .battle-log {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
            padding: 8px 12px;
            font-size: 10px;
            min-height: 40px;
        }

        .battle-ok {
            background: #fff;
            border-top: 4px solid #333;
            padding: 12px;
            display: none;
        }

        .battle-ok button {
            width: 100%;
            padding: 14px 12px;
            font-size: 12px;
            font-family: inherit;
            border: 3px solid #333;
            border-radius: 8px;
            cursor: pointer;
            background: #111827;
            color: #fff;
        }

        .moves-menu { display: none; background: #fff; border-top: 4px solid #333; padding: 12px; }
        .moves-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        
        .move-btn {
            padding: 10px; font-size: 10px;
            font-family: inherit; border: 3px solid #333;
            border-radius: 6px; cursor: pointer; text-align: left;
        }
        
        .move-btn .move-name { font-weight: bold; }
        .move-btn .move-pp { font-size: 8px; color: #333; }
        
        .type-normal { background: #a8a878; color: white; }
        .type-electric { background: #f8d030; color: #333; }
        .type-water { background: #6890f0; color: white; }
        .type-psychic { background: #f85888; color: white; }
        .type-grass { background: #78c850; color: white; }
        .type-fire { background: #f08030; color: white; }
        .type-poison { background: #a040a0; color: white; }
        
        .back-btn {
            margin-top: 8px; padding: 8px; width: 100%;
            background: #64748b; color: white;
            border: 2px solid #333; border-radius: 4px;
            cursor: pointer; font-family: inherit; font-size: 10px;
        }
        
        #titleScreen {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(180deg, #1e3a5f 0%, #0d1b2a 100%);
            display: none; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 5000; color: white;
        }
        
        #titleScreen h1 { font-size: 20px; margin-bottom: 8px; text-shadow: 2px 2px #000; color: #ffd700; }
        #titleScreen h2 { font-size: 11px; margin-bottom: 30px; color: #87ceeb; }
        
        #titleScreen button {
            padding: 12px 30px; font-size: 12px;
            font-family: inherit; background: #e63946; color: white;
            border: 3px solid #fff; border-radius: 8px;
            cursor: pointer; margin: 8px;
        }
        
        #titleScreen button:hover { background: #c1121f; }
        
        .title-pokemon { width: 96px; height: 96px; margin-bottom: 15px; image-rendering: pixelated; }
    </style>
</head>
<body>
    <div id="evolutionOverlay" class="evolution-overlay"></div>
    <div id="loadingScreen">
        <div>Loading sprites...</div>
        <div class="progress"><div class="progress-fill" id="progressFill"></div></div>
        <div id="loadingText" style="margin-top: 10px; font-size: 10px;"></div>
    </div>
    
    <div id="titleScreen">
        <img class="title-pokemon" id="titlePokemon" src="" alt="Poliwhirl">
        <h1>POKÉMON</h1>
        <h2>ADVENTURES - RED CHAPTER</h2>
        <button onclick="startNewGame()">NEW GAME</button>
        <button onclick="loadGame()">CONTINUE</button>
    </div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>
    
    <div class="controls">
        <div class="dpad">
            <button class="up" ontouchstart="startMove('up')" ontouchend="stopMove()" ontouchcancel="stopMove()" onmousedown="startMove('up')" onmouseup="stopMove()" onmouseleave="stopMove()">▲</button>
            <button class="left" ontouchstart="startMove('left')" ontouchend="stopMove()" ontouchcancel="stopMove()" onmousedown="startMove('left')" onmouseup="stopMove()" onmouseleave="stopMove()">◄</button>
            <button class="right" ontouchstart="startMove('right')" ontouchend="stopMove()" ontouchcancel="stopMove()" onmousedown="startMove('right')" onmouseup="stopMove()" onmouseleave="stopMove()">►</button>
            <button class="down" ontouchstart="startMove('down')" ontouchend="stopMove()" ontouchcancel="stopMove()" onmousedown="startMove('down')" onmouseup="stopMove()" onmouseleave="stopMove()">▼</button>
        </div>
        <div class="action-buttons">
            <button class="btn-b"
                onmousedown="setRunPressed(true)"
                onmouseup="setRunPressed(false)"
                onmouseleave="setRunPressed(false)"
                ontouchstart="setRunPressed(true)"
                ontouchend="setRunPressed(false)"
                onclick="handleB(event)">B</button>
            <button class="btn-a" onclick="handleA()">A</button>
        </div>
    </div>

    <div id="tapOverlay"></div>
    <div id="sceneBackdrop"></div>

    <div id="dialogBox">
        <div class="dialog-content">
            <img id="dialogPortrait" class="portrait" alt="portrait">
            <div class="text-wrap">
                <div class="speaker"></div>
                <div class="text"></div>
            </div>
        </div>
        <div class="continue">▼ Toque / A</div>
    </div>

    <div id="debugBar"></div>
    <div id="mapBanner"></div>
    
    <div id="battleScreen">
        <div class="battle-field" id="battleField">
            <div class="pokemon-slot enemy-slot">
                <img class="trainer-portrait" id="trainerPortrait" src="" style="display:none" alt="trainer">
                <div class="pokemon-info">
                    <div class="pokemon-name" id="enemyName">RATTATA</div>
                    <div class="pokemon-level" id="enemyLevel">Lv. 3</div>
                    <div class="hp-bar"><div class="hp-fill" id="enemyHp"></div></div>
                </div>
                <img class="pokemon-sprite" id="enemySprite" src="">
            </div>
            <div class="pokemon-slot player-slot">
                <img class="pokemon-sprite" id="playerSprite" src="">
                <div class="pokemon-info">
                    <div class="pokemon-name" id="playerName">PIKACHU</div>
                    <div class="pokemon-level" id="playerLevel">Lv. 5</div>
                    <div class="hp-bar"><div class="hp-fill" id="playerHp"></div></div>
                    <div style="font-size: 8px; margin-top: 3px;"><span id="playerCurrentHp">20</span>/<span id="playerMaxHp">20</span></div>
                </div>
            </div>
        </div>
        <div class="battle-log" id="battleLog">Um POKeMON selvagem apareceu!</div>
        <div class="battle-ok" id="battleOk">
            <button id="battleOkBtn" onclick="battleOk()">OK</button>
        </div>
        <div class="battle-menu" id="battleMenu">
            <button class="fight" onclick="showMoves()">FIGHT</button>
            <button class="bag" onclick="useBag()">BAG</button>
            <button class="pokemon" onclick="showPokemon()">POKéMON</button>
            <button class="run" onclick="tryRun()">RUN</button>
        </div>
        <div class="moves-menu" id="movesMenu">
            <div class="moves-grid" id="movesGrid"></div>
            <button class="back-btn" onclick="hideMoves()">BACK</button>
        </div>
    </div>

    <script src="./story/season1.ptbr.inline.js"></script>
    <script>
    // ==================== CONFIG ====================
    const TILE = 16;
    const SCALE = 2;
    const ST = TILE * SCALE; // Scaled tile
    const VW = 15; // View width in tiles
    const VH = 11; // View height in tiles
    
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = VW * ST;
    canvas.height = VH * ST;
    ctx.imageSmoothingEnabled = false;
    
    // ==================== SPRITE SOURCES ====================
    const DEFAULT_SPRITE_URLS = {
        red: './assets/tilesets/characters/red_normal.png',
        blue: './assets/tilesets/characters/blue.png',
        brock: './assets/tilesets/characters/brock.png',
        oak: './assets/tilesets/characters/prof_oak.png',
        mom: './assets/tilesets/characters/mom.png',
        girl: './assets/tilesets/characters/lass.png',
        green: './assets/tilesets/characters/green_normal.png',
        pikachuOW: './assets/tilesets/characters/pikachu.png',
        pikachuBattle: './assets/tilesets/pokemon_sprites/pikachu_front.png',
        pikachuBack: './assets/tilesets/pokemon_sprites/pikachu_back.png',
        rattata: './assets/tilesets/pokemon_sprites/rattata_front.png',
        pidgey: './assets/tilesets/pokemon_sprites/pidgey_front.png',
        staryu: './assets/tilesets/pokemon_sprites/staryu_front.png',
        poliwhirl: './assets/tilesets/pokemon_sprites/poliwhirl_front.png',
        poliwhirlBack: './assets/tilesets/pokemon_sprites/poliwhirl_back.png',
        poliwrath: './assets/tilesets/pokemon_sprites/poliwrath_front.png',
        poliwrathBack: './assets/tilesets/pokemon_sprites/poliwrath_back.png',
        bulbasaur: './assets/tilesets/pokemon_sprites/bulbasaur_front.png',
        bulbasaurBack: './assets/tilesets/pokemon_sprites/bulbasaur_back.png',
        ivysaur: './assets/tilesets/pokemon_sprites/ivysaur_front.png',
        ivysaurBack: './assets/tilesets/pokemon_sprites/ivysaur_back.png',
        venusaur: './assets/tilesets/pokemon_sprites/venusaur_front.png',
        venusaurBack: './assets/tilesets/pokemon_sprites/venusaur_back.png',
        snorlax: './assets/tilesets/pokemon_sprites/snorlax_front.png',
        gyarados: './assets/tilesets/pokemon_sprites/gyarados_front.png',
        charmander: './assets/tilesets/pokemon_sprites/charmander_front.png',
        charmeleon: './assets/tilesets/pokemon_sprites/charmeleon_front.png',
        charizard: './assets/tilesets/pokemon_sprites/charizard_front.png',
        squirtle: './assets/tilesets/pokemon_sprites/squirtle_front.png',
        wartortle: './assets/tilesets/pokemon_sprites/wartortle_front.png',
        mew: './assets/tilesets/pokemon_sprites/mew_front.png',
        kangaskhan: './assets/tilesets/pokemon_sprites/kangaskhan_front.png',
        nidoking: './assets/tilesets/pokemon_sprites/nidoking_front.png',
        koffing: './assets/tilesets/pokemon_sprites/koffing_front.png',
        ekans: './assets/tilesets/pokemon_sprites/ekans_front.png',
        arbok: './assets/tilesets/pokemon_sprites/arbok_front.png',
        geodude: './assets/tilesets/pokemon_sprites/geodude_front.png',
        onix: './assets/tilesets/pokemon_sprites/onix_front.png',
        raticate: './assets/tilesets/pokemon_sprites/020_raticate_front.png',
        alakazam: './assets/tilesets/pokemon_sprites/065_alakazam_front.png',
        gengar: './assets/tilesets/pokemon_sprites/094_gengar_front.png',
        electabuzz: './assets/tilesets/pokemon_sprites/125_electabuzz_front.png',
        dragonite: './assets/tilesets/pokemon_sprites/149_dragonite_front.png',
        mewtwo: './assets/tilesets/pokemon_sprites/150_mewtwo_front.png',
        pikachu: './assets/tilesets/pokemon_sprites/pikachu_front.png',
        trainerBlue: './assets/tilesets/trainers/rival_early_front_pic.png',
        trainerBrock: './assets/tilesets/trainers/leader_brock_front_pic.png',
        trainerRocket: './assets/tilesets/trainers/rocket_grunt_m_front_pic.png',
        trainerGiovanni: './assets/tilesets/trainers/leader_giovanni_front_pic.png',
        trainerLance: './assets/tilesets/trainers/elite_four_lance_front_pic.png',
        trainerOak: './assets/tilesets/trainers/professor_oak_front_pic.png'
    };
    const REQUIRED_SPRITE_KEYS = new Set(Object.keys(DEFAULT_SPRITE_URLS));

    const BATTLE_TERRAIN_URLS = {
        grass: './assets/tilesets/battle_terrain/grass/terrain.png',
        longgrass: './assets/tilesets/battle_terrain/longgrass/terrain.png',
        building: './assets/tilesets/battle_terrain/building/terrain.png',
        cave: './assets/tilesets/battle_terrain/cave/terrain.png',
        mountain: './assets/tilesets/battle_terrain/mountain/terrain.png',
        water: './assets/tilesets/battle_terrain/water/terrain.png',
        pond: './assets/tilesets/battle_terrain/pond/terrain.png',
    };

    const UI_SKIN_URLS = {
        menu: './assets/tilesets/missing_tiles/13_ui_battle_interface.png',
        log: './assets/tilesets/manual_ui/battle_ui_2.png',
        ok: './assets/tilesets/manual_ui/battle_ui_1.png',
        arrow: './assets/tilesets/interface/red_arrow.png',
        selectBtn: './assets/tilesets/interface/select_button.png',
        bag: './assets/tilesets/missing_tiles/18_ui_bag_inventory.png'
    };
    
    // Active sprite sources (can be overridden via local/remote JSON config)
    let SPRITE_URLS = {...DEFAULT_SPRITE_URLS};

    // Loaded images
    const sprites = {};
    let loadedCount = 0;
    const prebuiltMapBg = {};
    const DEFAULT_PREBUILT_MAP_BG_CONFIG = {
        // Uses ripped map sheets as visual background while preserving collision/warps from engine maps.
        pallet_town: {url: './assets/tilesets/cities/3873_city_pallet_town.png', ts: 16, px: 8, py: 24},
        route1: {url: './assets/tilesets/missing_tiles/05_map_route_1.png', ts: 16, px: 8, py: 24},
        viridian: {url: './assets/tilesets/cities/3874_city_viridian.png', ts: 16, px: 8, py: 24},
        pewter: {url: './assets/tilesets/cities/3875_city_pewter.png', ts: 16, px: 8, py: 24},
        route2: {url: './assets/tilesets/cities/3876_city_map_3876.png', ts: 16, px: 8, py: 24},
        route3: {url: './assets/tilesets/cities/3878_city_map_3878.png', ts: 16, px: 8, py: 24},
        cerulean: {url: './assets/tilesets/missing_tiles/15_map_route_4_center.png', ts: 16, px: 8, py: 24},
        vermilion: {url: './assets/tilesets/missing_tiles/16_map_route_6_house.png', ts: 16, px: 8, py: 24},
        lavender: {url: './assets/tilesets/manual_environmental/environmental_4.png', ts: 16, ox: 0, oy: 0},
        fuchsia: {url: './assets/tilesets/missing_tiles/19_map_route_11_gate.png', ts: 16, px: 8, py: 24},
        cinnabar: {url: './assets/tilesets/manual_environmental/one_island.png', ts: 16, ox: 0, oy: 0},
        viridian_forest: {url: './assets/tilesets/missing_tiles/02_map_route_10.png', ts: 16, px: 8, py: 24},
        // Reuse city sheets that already include the matching interiors/gym panels.
        viridian_gym: {url: './assets/tilesets/cities/3874_city_viridian.png', ts: 16, px: 1008, py: 24, fixed: true},
        pewter_gym: {url: './assets/tilesets/cities/3875_city_pewter.png', ts: 16, px: 696, py: 408, fixed: true},
        player_house: {url: './assets/tilesets/cities/3873_city_pallet_town.png', ts: 16, px: 392, py: 40, fixed: true},
        rival_house: {url: './assets/tilesets/cities/3873_city_pallet_town.png', ts: 16, px: 392, py: 200, fixed: true},
        oak_lab: {url: './assets/tilesets/cities/3873_city_pallet_town.png', ts: 16, px: 776, py: 24, fixed: true},
        mt_moon: {url: './assets/tilesets/manual_environmental/mt_moon.png', ts: 16, px: 8, py: 24},
        saffron: {url: './assets/tilesets/manual_environmental/saffron_city.png', ts: 16, px: 8, py: 24},
        indigo_plateau: {url: './assets/tilesets/manual_environmental/indigo_plateau.png', ts: 16, px: 8, py: 24},
        silph_lobby: {url: './assets/tilesets/manual_environmental/rocket_hideout.png', ts: 16, px: 792, py: 24, fixed: true}
    };
    let PREBUILT_MAP_BG_CONFIG = {...DEFAULT_PREBUILT_MAP_BG_CONFIG};
    // Story controls:
    // - autocutmove=1 (default): scripted scene walk enabled.
    // - autodialog=0 (default): dialog advances on user tap/A, not automatically.
    // Cutscene auto-walk: enabled by default for intro/story flow.
    // Disable with ?autocutmove=0 if causing issues on specific devices.
    const AUTO_CUTSCENE_MOVE = qs('autocutmove', '1') === '1';
    const AUTO_DIALOG_ADVANCE = qs('autodialog', '0') === '1';
    const DEFAULT_SCENE_BACKDROP = './assets/tilesets/missing_tiles/05_map_route_1.png';
    const DEFAULT_SCENE_BACKDROP_RULES = [
        {match: 'pallet|oak|ch1_intro|ch1_oak', url: './assets/tilesets/cities/3873_city_pallet_town.png'},
        {match: 'viridian_forest|forest|bug', url: './assets/tilesets/missing_tiles/02_map_route_10.png'},
        {match: 'viridian|giovanni', url: './assets/tilesets/cities/3874_city_viridian.png'},
        {match: 'pewter|brock|museum|fossil', url: './assets/tilesets/cities/3875_city_pewter.png'},
        {match: 'mtmoon|moon|cave', url: './assets/tilesets/manual_environmental/mt_moon.png'},
        {match: 'cerulean|misty|bill', url: './assets/tilesets/missing_tiles/15_map_route_4_center.png'},
        {match: 'vermilion|surge|ssanne', url: './assets/tilesets/missing_tiles/16_map_route_6_house.png'},
        {match: 'lavender|shadow|ghost|gengar|hypno', url: './assets/tilesets/manual_environmental/environmental_4.png'},
        {match: 'saffron|psychic|alakazam', url: './assets/tilesets/manual_environmental/saffron_city.png'},
        {match: 'silph|rocket', url: './assets/tilesets/manual_environmental/rocket_hideout.png'},
        {match: 'fuchsia|safari|koga', url: './assets/tilesets/missing_tiles/19_map_route_11_gate.png'},
        {match: 'cinnabar|research|mewtwo', url: './assets/tilesets/manual_environmental/one_island.png'},
        {match: 'indigo|elite|champion|lance|agatha|bruno|lorelei', url: './assets/tilesets/manual_environmental/indigo_plateau.png'}
    ];
    let SCENE_BACKDROP_DEFAULT = DEFAULT_SCENE_BACKDROP;
    let SCENE_BACKDROP_RULES = [...DEFAULT_SCENE_BACKDROP_RULES];

    const MAP_LABELS = {
        pallet_town: 'Pallet Town',
        route1: 'Route 1',
        viridian: 'Viridian City',
        route2: 'Route 2',
        viridian_forest: 'Viridian Forest',
        pewter: 'Pewter City',
        pewter_gym: 'Pewter Gym',
        route3: 'Route 3',
        mt_moon: 'Mt. Moon',
        cerulean: 'Cerulean City',
        vermilion: 'Vermilion City',
        lavender: 'Lavender Town',
        saffron: 'Saffron City',
        silph_lobby: 'Silph Co.',
        fuchsia: 'Fuchsia City',
        cinnabar: 'Cinnabar Island',
        viridian_gym: 'Viridian Gym',
        indigo_plateau: 'Indigo Plateau',
        player_house: 'Red House',
        rival_house: 'Blue House',
        oak_lab: 'Oak Lab'
    };

    // Composite map sheets are visually rich. We only skip the known problematic maps
    // where overlays visibly diverge from collision/warp logic.
    function buildPrebuiltSkipSet() {
        const raw = qs('mapbgskip', '').trim();
        if (!raw) return new Set();
        return new Set(raw.split(',').map(s => s.trim()).filter(Boolean));
    }
    const PREBUILT_SKIP_MAPS = buildPrebuiltSkipSet();
    const STYLE_LOCK_CORE_MAPS = new Set([
        'pallet_town', 'route1', 'viridian', 'route2', 'viridian_forest',
        'pewter', 'route3', 'mt_moon', 'cerulean', 'vermilion',
        'lavender', 'saffron', 'silph_lobby', 'fuchsia', 'cinnabar',
        'viridian_gym', 'indigo_plateau', 'pewter_gym',
        'player_house', 'rival_house', 'oak_lab'
    ]);
    // By default, prefer prebuilt visual sheets for fidelity.
    // Keep this set empty unless a specific map needs emergency tile-only rendering.
    const ALWAYS_TILE_RENDER_MAPS = new Set([]);
    
    // ==================== COLORS (FRLG-ish, but original) ====================
    const C = {
        grass: '#6fbf4a', grass2: '#5aa83a', grass3: '#4f9533',
        path: '#d7bf8a', path2: '#c9ad71', path3: '#b7975f',
        water: '#4a87c9', water2: '#3974b6', water3: '#2f619c',
        tree: '#2b7f3a', tree2: '#256d33', trunk: '#8a5a2b',
        roofR: '#c23d3d', roofR2: '#a62e2e',
        roofB: '#2f6db6', roofB2: '#255a96',
        roofG: '#2f9b6b', roofG2: '#237b55',
        wall: '#efe4c7', wall2: '#e2d4b2',
        fence: '#caa46b', fence2: '#b99258',
        sign: '#a46a2c',
        shadow: '#1b1b1b',
        flower: '#e46aa3'
    };
    
    // ==================== TILE TYPES ====================
    const T = {
        GRASS: 0, PATH: 1, WATER: 2, TREE: 3,
        HOUSE_RED: 4, HOUSE_BLUE: 5, LAB: 6,
        FENCE: 7, SIGN: 8, TALL_GRASS: 9,
        FLOWER: 10, LEDGE: 11, WARP: 13, NPC: 14,
        FLOOR_IN: 15, WALL_IN: 16, TABLE: 17, SHELF: 18,
        // Missing exterior tiles (for roofs & walls):
        ROOF_RED: 19, ROOF_BLUE: 20, ROOF_LAB: 21,
        WALL: 22, WINDOW: 23,
        // Variants:
        GRASS_ALT: 24, PATH_ALT: 25, DOOR: 26
    };
    
    const SOLID = [
        T.WATER, T.TREE, T.ROOF_RED, T.ROOF_BLUE, T.ROOF_LAB,
        T.HOUSE_RED, T.HOUSE_BLUE, T.LAB, T.FENCE, T.NPC,
        T.WALL_IN, T.TABLE, T.SHELF, T.WALL, T.WINDOW
    ];
    
    // ==================== MAPS ====================
    const MAPS = {
        pallet_town: {
            w: 20, h: 18,
            data: (() => {
                const w = 20, h = 18;
                const m = new Array(w * h).fill(T.GRASS);

                // Border trees (keep south gate open to Route 1).
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        if (x === 0 || x === w - 1 || y === 0) m[y * w + x] = T.TREE;
                    }
                }

                // South transition row and gate.
                for (let x = 0; x < w; x++) m[(h - 1) * w + x] = T.TALL_GRASS;
                m[(h - 1) * w + 9] = T.WARP;
                m[(h - 1) * w + 10] = T.WARP;

                // Main road + cross road.
                for (let y = 1; y <= 16; y++) {
                    m[y * w + 9] = T.PATH;
                    m[y * w + 10] = T.PATH;
                }
                for (let x = 2; x <= 17; x++) m[8 * w + x] = T.PATH;

                // Player house (left), rival house (right), Oak lab (south-center).
                for (let y = 3; y <= 5; y++) for (let x = 3; x <= 5; x++) m[y * w + x] = T.HOUSE_RED;
                for (let y = 3; y <= 5; y++) for (let x = 13; x <= 15; x++) m[y * w + x] = T.HOUSE_BLUE;
                for (let y = 9; y <= 11; y++) for (let x = 7; x <= 11; x++) m[y * w + x] = T.LAB;

                // Building entrances as warp tiles.
                m[6 * w + 4] = T.WARP;
                m[6 * w + 14] = T.WARP;
                m[12 * w + 9] = T.WARP;

                // Town details.
                m[7 * w + 11] = T.SIGN;
                m[2 * w + 2] = T.FLOWER;
                m[2 * w + 17] = T.FLOWER;
                m[14 * w + 3] = T.FLOWER;
                m[14 * w + 16] = T.FLOWER;
                for (let x = 6; x <= 12; x++) m[10 * w + x] = T.FENCE;

                return m;
            })(),
            warps: [
                {x:4,y:6,to:'player_house',tx:3,ty:6},
                {x:14,y:6,to:'rival_house',tx:3,ty:6},
                {x:9,y:12,to:'oak_lab',tx:5,ty:10},
                {x:9,y:17,to:'route1',tx:9,ty:23},
                {x:10,y:17,to:'route1',tx:10,ty:23}
            ],
            npcs: [
                {x:15,y:10,name:'Girl',sprite:'girl',dialog:[
                    'Bem-vindo a PALLET TOWN!',
                    'Ouviu o boato? Dizem que viram uma luz estranha na floresta!',
                    'O Professor OAK esta investigando isso no laboratorio...'
                ]},
                {x:13,y:7,name:'Blue',sprite:'blue',dialog:[
                    '...Ah. Voce, RED.',
                    'O velho falou de um POKeMON raro avistado por aqui.',
                    'Nao ache que vai chegar antes de mim.',
                    'Eu sempre estou um passo a frente. Ate mais.'
                ]}
            ],
            enc: null
        },
        
        route1: {
            w: 20, h: 25,
            data: (() => {
                let m = [];
                for (let y = 0; y < 25; y++) {
                    for (let x = 0; x < 20; x++) {
                        if (x === 0 || x === 19) m.push(T.TREE);
                        else if (y === 24 && (x === 9 || x === 10)) m.push(T.WARP);
                        else if (y === 0 && (x === 9 || x === 10)) m.push(T.WARP);
                        else if (x === 9 || x === 10) m.push(T.PATH);
                        else if ((y >= 4 && y <= 9 && (x <= 6 || x >= 13)) || (y >= 14 && y <= 18 && (x <= 5 || x >= 14))) m.push(T.TALL_GRASS);
                        else m.push(T.GRASS);
                    }
                }
                return m;
            })(),
            warps: [
                {x:9,y:0,to:'viridian',tx:9,ty:16},
                {x:10,y:0,to:'viridian',tx:10,ty:16},
                {x:9,y:24,to:'pallet_town',tx:9,ty:16},
                {x:10,y:24,to:'pallet_town',tx:10,ty:16}
            ],
            npcs: [],
            enc: {pokemon:[{name:'RATTATA',spr:'rattata',lv:[2,4],rate:55},{name:'PIDGEY',spr:'pidgey',lv:[2,5],rate:45}],rate:12}
        },

        // Minimal Viridian City (static layout, story-first; no RNG required)
        viridian: {
            w: 20, h: 18,
            data: (() => {
                const w = 20, h = 18;
                const m = new Array(w * h).fill(T.GRASS);
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.TREE;
                    }
                }
                // Main road (south <-> north)
                for (let y = 1; y < h - 1; y++) {
                    m[y * w + 9] = T.PATH;
                    m[y * w + 10] = T.PATH;
                }
                // Plaza
                for (let y = 6; y <= 9; y++) for (let x = 6; x <= 13; x++) m[y * w + x] = T.PATH;
                // WARP tiles
                m[0 * w + 9] = T.WARP; m[0 * w + 10] = T.WARP;
                m[(h - 1) * w + 9] = T.WARP; m[(h - 1) * w + 10] = T.WARP;
                // Forest gate (east)
                m[8 * w + (w - 1)] = T.WARP;
                // Simple sign
                m[10 * w + 8] = T.SIGN;
                return m;
            })(),
            warps: [
                {x:9,y:17,to:'route1',tx:9,ty:1},
                {x:10,y:17,to:'route1',tx:10,ty:1},
                {x:9,y:0,to:'route2',tx:9,ty:23},
                {x:10,y:0,to:'route2',tx:10,ty:23},
                {x:19,y:8,to:'viridian_forest',tx:2,ty:12},
            ],
            npcs: [
                {x:10,y:8,name:'Girl',sprite:'girl',dialog:[
                    'VIRIDIAN CITY...',
                    'Dizem que o GINASIO esta fechado.',
                    'E que a floresta esta... estranha.'
                ]},
            ],
            enc: null
        },

        // Route 2: Viridian -> Pewter (no RNG when storyLock=true)
        route2: {
            w: 20, h: 25,
            data: (() => {
                const w = 20, h = 25;
                const m = new Array(w * h).fill(T.GRASS);
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        if (x === 0 || x === w - 1) m[y * w + x] = T.TREE;
                        else if (y === 0 || y === h - 1) m[y * w + x] = T.TREE;
                    }
                }
                // Path
                for (let y = 1; y < h - 1; y++) {
                    m[y * w + 9] = T.PATH;
                    m[y * w + 10] = T.PATH;
                }
                // Tall grass patches
                for (let y = 6; y <= 10; y++) for (let x = 3; x <= 6; x++) m[y * w + x] = T.TALL_GRASS;
                for (let y = 13; y <= 17; y++) for (let x = 13; x <= 16; x++) m[y * w + x] = T.TALL_GRASS;

                // Warps
                m[(h - 1) * w + 9] = T.WARP; m[(h - 1) * w + 10] = T.WARP;
                m[0 * w + 9] = T.WARP; m[0 * w + 10] = T.WARP;
                return m;
            })(),
            warps: [
                {x:9,y:24,to:'viridian',tx:9,ty:1},
                {x:10,y:24,to:'viridian',tx:10,ty:1},
                {x:9,y:0,to:'pewter',tx:9,ty:16},
                {x:10,y:0,to:'pewter',tx:10,ty:16},
            ],
            npcs: [],
            enc: {pokemon:[{name:'RATTATA',spr:'rattata',lv:[3,5],rate:50},{name:'PIDGEY',spr:'pidgey',lv:[3,6],rate:50}],rate:10}
        },

        // Pewter City (minimal; Pikachu arc will be triggered here)
        pewter: {
            w: 20, h: 18,
            data: (() => {
                const w = 20, h = 18;
                const m = new Array(w * h).fill(T.GRASS);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.TREE;
                }
                for (let y = 1; y < h - 1; y++) {
                    m[y * w + 9] = T.PATH;
                    m[y * w + 10] = T.PATH;
                }
                for (let y = 6; y <= 11; y++) for (let x = 6; x <= 13; x++) m[y * w + x] = T.PATH;
                // Pewter Gym
                for (let y = 3; y <= 5; y++) for (let x = 8; x <= 11; x++) m[y * w + x] = T.LAB;
                m[6 * w + 9] = T.WARP;
                // North exit to Route 3
                m[0 * w + 9] = T.WARP; m[0 * w + 10] = T.WARP;
                // Warps (south back to route2)
                m[(h - 1) * w + 9] = T.WARP; m[(h - 1) * w + 10] = T.WARP;
                // Sign near center
                m[11 * w + 8] = T.SIGN;
                return m;
            })(),
            warps: [
                {x:9,y:17,to:'route2',tx:9,ty:1},
                {x:10,y:17,to:'route2',tx:10,ty:1},
                {x:9,y:6,to:'pewter_gym',tx:5,ty:9},
                {x:9,y:0,to:'route3',tx:1,ty:8},
                {x:10,y:0,to:'route3',tx:1,ty:9}
            ],
            npcs: [
                {x:10,y:9,name:'Girl',sprite:'girl',dialog:[
                    'PEWTER CITY.',
                    'A cidade das rochas.',
                    '...E dizem que ha um POKeMON estranho por aqui.'
                ]},
            ],
            enc: null
        },

        route3: {
            w: 20, h: 16,
            data: (() => {
                const w = 20, h = 16;
                const m = new Array(w * h).fill(T.GRASS);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.TREE;
                }
                for (let x = 1; x < w - 1; x++) {
                    m[8 * w + x] = T.PATH;
                    m[9 * w + x] = T.PATH;
                }
                for (let y = 3; y <= 5; y++) for (let x = 4; x <= 7; x++) m[y * w + x] = T.TALL_GRASS;
                for (let y = 10; y <= 12; y++) for (let x = 12; x <= 15; x++) m[y * w + x] = T.TALL_GRASS;
                m[8 * w + 0] = T.WARP; m[9 * w + 0] = T.WARP;
                m[8 * w + (w - 1)] = T.WARP; m[9 * w + (w - 1)] = T.WARP;
                return m;
            })(),
            warps: [
                {x:0,y:8,to:'pewter',tx:9,ty:1},
                {x:0,y:9,to:'pewter',tx:10,ty:1},
                {x:19,y:8,to:'mt_moon',tx:1,ty:8},
                {x:19,y:9,to:'mt_moon',tx:1,ty:9}
            ],
            npcs: [],
            enc: {pokemon:[{name:'RATTATA',spr:'rattata',lv:[6,8],rate:50},{name:'PIDGEY',spr:'pidgey',lv:[6,8],rate:50}],rate:10}
        },

        mt_moon: {
            w: 24, h: 16,
            data: (() => {
                const w = 24, h = 16;
                const m = new Array(w * h).fill(T.FLOOR_IN);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.WALL_IN;
                }
                m[8 * w + 0] = T.WARP; m[9 * w + 0] = T.WARP;
                m[8 * w + (w - 1)] = T.WARP; m[9 * w + (w - 1)] = T.WARP;
                m[4 * w + 6] = T.TABLE; m[4 * w + 17] = T.TABLE;
                m[10 * w + 9] = T.TABLE; m[10 * w + 14] = T.TABLE;
                m[2 * w + 11] = T.SHELF;
                return m;
            })(),
            warps: [
                {x:0,y:8,to:'route3',tx:18,ty:8},
                {x:0,y:9,to:'route3',tx:18,ty:9},
                {x:23,y:8,to:'cerulean',tx:1,ty:10},
                {x:23,y:9,to:'cerulean',tx:1,ty:11}
            ],
            npcs: [],
            enc: null
        },

        cerulean: {
            w: 22, h: 18,
            data: (() => {
                const w = 22, h = 18;
                const m = new Array(w * h).fill(T.GRASS);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.TREE;
                }
                for (let y = 1; y < h - 1; y++) { m[y * w + 10] = T.PATH; m[y * w + 11] = T.PATH; }
                for (let x = 2; x < w - 2; x++) m[9 * w + x] = T.PATH;
                for (let y = 4; y <= 6; y++) for (let x = 13; x <= 16; x++) m[y * w + x] = T.WATER;
                m[10 * w + 0] = T.WARP; m[11 * w + 0] = T.WARP;
                m[10 * w + (w - 1)] = T.WARP; m[11 * w + (w - 1)] = T.WARP;
                return m;
            })(),
            warps: [
                {x:0,y:10,to:'mt_moon',tx:22,ty:8},
                {x:0,y:11,to:'mt_moon',tx:22,ty:9},
                {x:21,y:10,to:'vermilion',tx:1,ty:10},
                {x:21,y:11,to:'vermilion',tx:1,ty:11}
            ],
            npcs: [],
            enc: null
        },

        vermilion: {
            w: 22, h: 18,
            data: (() => {
                const w = 22, h = 18;
                const m = new Array(w * h).fill(T.GRASS);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.TREE;
                }
                for (let y = 1; y < h - 1; y++) { m[y * w + 10] = T.PATH; m[y * w + 11] = T.PATH; }
                for (let x = 2; x < w - 2; x++) m[10 * w + x] = T.PATH;
                for (let y = 3; y <= 6; y++) for (let x = 15; x <= 20; x++) m[y * w + x] = T.WATER;
                m[10 * w + 0] = T.WARP; m[11 * w + 0] = T.WARP;
                m[10 * w + (w - 1)] = T.WARP; m[11 * w + (w - 1)] = T.WARP;
                return m;
            })(),
            warps: [
                {x:0,y:10,to:'cerulean',tx:20,ty:10},
                {x:0,y:11,to:'cerulean',tx:20,ty:11},
                {x:21,y:10,to:'lavender',tx:1,ty:10},
                {x:21,y:11,to:'lavender',tx:1,ty:11}
            ],
            npcs: [],
            enc: null
        },

        lavender: {
            w: 22, h: 18,
            data: (() => {
                const w = 22, h = 18;
                const m = new Array(w * h).fill(T.GRASS);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.TREE;
                }
                for (let y = 1; y < h - 1; y++) { m[y * w + 10] = T.PATH; m[y * w + 11] = T.PATH; }
                for (let x = 3; x <= 18; x++) m[10 * w + x] = T.PATH;
                for (let y = 4; y <= 6; y++) for (let x = 5; x <= 7; x++) m[y * w + x] = T.LAB;
                m[10 * w + 0] = T.WARP; m[11 * w + 0] = T.WARP;
                m[10 * w + (w - 1)] = T.WARP; m[11 * w + (w - 1)] = T.WARP;
                return m;
            })(),
            warps: [
                {x:0,y:10,to:'vermilion',tx:20,ty:10},
                {x:0,y:11,to:'vermilion',tx:20,ty:11},
                {x:21,y:10,to:'saffron',tx:1,ty:10},
                {x:21,y:11,to:'saffron',tx:1,ty:11}
            ],
            npcs: [],
            enc: null
        },

        saffron: {
            w: 22, h: 18,
            data: (() => {
                const w = 22, h = 18;
                const m = new Array(w * h).fill(T.GRASS);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.TREE;
                }
                for (let y = 1; y < h - 1; y++) { m[y * w + 10] = T.PATH; m[y * w + 11] = T.PATH; }
                for (let x = 2; x < w - 2; x++) m[9 * w + x] = T.PATH;
                for (let y = 4; y <= 7; y++) for (let x = 14; x <= 17; x++) m[y * w + x] = T.LAB;
                m[10 * w + 0] = T.WARP; m[11 * w + 0] = T.WARP;
                m[10 * w + (w - 1)] = T.WARP; m[11 * w + (w - 1)] = T.WARP;
                // Story progression exits
                m[0 * w + 10] = T.WARP; m[0 * w + 11] = T.WARP;       // north -> fuchsia
                m[(h - 1) * w + 10] = T.WARP; m[(h - 1) * w + 11] = T.WARP; // south -> viridian_gym
                return m;
            })(),
            warps: [
                {x:0,y:10,to:'lavender',tx:20,ty:10},
                {x:0,y:11,to:'lavender',tx:20,ty:11},
                {x:21,y:10,to:'silph_lobby',tx:2,ty:10},
                {x:21,y:11,to:'silph_lobby',tx:2,ty:10},
                {x:10,y:0,to:'fuchsia',tx:10,ty:16},
                {x:11,y:0,to:'fuchsia',tx:11,ty:16},
                {x:10,y:17,to:'viridian_gym',tx:10,ty:15},
                {x:11,y:17,to:'viridian_gym',tx:11,ty:15}
            ],
            npcs: [],
            enc: null
        },

        silph_lobby: {
            w: 14, h: 12,
            data: (() => {
                const w = 14, h = 12;
                const m = new Array(w * h).fill(T.FLOOR_IN);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.WALL_IN;
                }
                m[10 * w + 2] = T.WARP;
                m[2 * w + 4] = T.SHELF; m[2 * w + 9] = T.SHELF;
                m[5 * w + 4] = T.TABLE; m[5 * w + 9] = T.TABLE;
                return m;
            })(),
            warps: [{x:2,y:10,to:'saffron',tx:20,ty:10}],
            npcs: [],
            enc: null
        },

        fuchsia: {
            w: 22, h: 18,
            data: (() => {
                const w = 22, h = 18;
                const m = new Array(w * h).fill(T.GRASS);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.TREE;
                }
                for (let y = 1; y < h - 1; y++) { m[y * w + 10] = T.PATH; m[y * w + 11] = T.PATH; }
                for (let x = 3; x <= 18; x++) m[9 * w + x] = T.PATH;
                for (let y = 4; y <= 6; y++) for (let x = 4; x <= 7; x++) m[y * w + x] = T.WATER;
                for (let y = 4; y <= 6; y++) for (let x = 14; x <= 17; x++) m[y * w + x] = T.HOUSE_RED;
                m[0 * w + 10] = T.WARP; m[0 * w + 11] = T.WARP; // to saffron
                m[(h - 1) * w + 10] = T.WARP; m[(h - 1) * w + 11] = T.WARP; // to cinnabar
                return m;
            })(),
            warps: [
                {x:10,y:0,to:'saffron',tx:10,ty:1},
                {x:11,y:0,to:'saffron',tx:11,ty:1},
                {x:10,y:17,to:'cinnabar',tx:10,ty:1},
                {x:11,y:17,to:'cinnabar',tx:11,ty:1}
            ],
            npcs: [],
            enc: null
        },

        cinnabar: {
            w: 22, h: 18,
            data: (() => {
                const w = 22, h = 18;
                const m = new Array(w * h).fill(T.PATH);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.WATER;
                }
                for (let y = 3; y <= 7; y++) for (let x = 7; x <= 14; x++) m[y * w + x] = T.GRASS;
                for (let y = 9; y <= 13; y++) for (let x = 8; x <= 13; x++) m[y * w + x] = T.LAB;
                m[0 * w + 10] = T.WARP; m[0 * w + 11] = T.WARP; // to fuchsia
                m[(h - 1) * w + 10] = T.WARP; m[(h - 1) * w + 11] = T.WARP; // to indigo
                return m;
            })(),
            warps: [
                {x:10,y:0,to:'fuchsia',tx:10,ty:16},
                {x:11,y:0,to:'fuchsia',tx:11,ty:16},
                {x:10,y:17,to:'indigo_plateau',tx:10,ty:1},
                {x:11,y:17,to:'indigo_plateau',tx:11,ty:1}
            ],
            npcs: [],
            enc: null
        },

        viridian_gym: {
            w: 22, h: 18,
            data: (() => {
                const w = 22, h = 18;
                const m = new Array(w * h).fill(T.FLOOR_IN);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.WALL_IN;
                }
                for (let y = 4; y <= 12; y++) { m[y * w + 10] = T.PATH; m[y * w + 11] = T.PATH; }
                m[15 * w + 10] = T.WARP; m[15 * w + 11] = T.WARP; // to saffron
                m[1 * w + 10] = T.WARP; m[1 * w + 11] = T.WARP;   // to indigo
                m[5 * w + 6] = T.TABLE; m[5 * w + 15] = T.TABLE;
                m[9 * w + 6] = T.TABLE; m[9 * w + 15] = T.TABLE;
                return m;
            })(),
            warps: [
                {x:10,y:15,to:'saffron',tx:10,ty:16},
                {x:11,y:15,to:'saffron',tx:11,ty:16},
                {x:10,y:1,to:'indigo_plateau',tx:10,ty:15},
                {x:11,y:1,to:'indigo_plateau',tx:11,ty:15}
            ],
            npcs: [],
            enc: null
        },

        indigo_plateau: {
            w: 22, h: 18,
            data: (() => {
                const w = 22, h = 18;
                const m = new Array(w * h).fill(T.FLOOR_IN);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || x === w - 1 || y === 0 || y === h - 1) m[y * w + x] = T.WALL_IN;
                }
                for (let y = 2; y <= 15; y++) { m[y * w + 10] = T.PATH; m[y * w + 11] = T.PATH; }
                m[15 * w + 10] = T.WARP; m[15 * w + 11] = T.WARP; // back to gym
                m[2 * w + 10] = T.SIGN;
                m[4 * w + 4] = T.SHELF; m[4 * w + 17] = T.SHELF;
                m[8 * w + 4] = T.TABLE; m[8 * w + 17] = T.TABLE;
                return m;
            })(),
            warps: [
                {x:10,y:15,to:'viridian_gym',tx:10,ty:2},
                {x:11,y:15,to:'viridian_gym',tx:11,ty:2}
            ],
            npcs: [],
            enc: null
        },

        pewter_gym: {
            w: 12, h: 10,
            data: (() => {
                const w = 12, h = 10;
                const m = new Array(w * h).fill(T.FLOOR_IN);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || y === 0 || x === w - 1 || y === h - 1) m[y * w + x] = T.WALL_IN;
                }
                // Exit
                m[9 * w + 5] = T.WARP;
                // Rock-like props / arena
                m[3 * w + 3] = T.TABLE;
                m[3 * w + 8] = T.TABLE;
                m[5 * w + 2] = T.TABLE;
                m[5 * w + 9] = T.TABLE;
                m[1 * w + 2] = T.SHELF;
                m[1 * w + 9] = T.SHELF;
                return m;
            })(),
            warps: [{x:5,y:9,to:'pewter',tx:9,ty:7}],
            npcs: [{x:5,y:2,name:'Brock',sprite:'brock',dialog:['...']}],
            enc: null
        },
        
        viridian_forest: {
            w: 20,
            h: 25,
            data: (() => {
                let m = [];
                for (let y = 0; y < 25; y++) {
                    for (let x = 0; x < 20; x++) {
                        // Map boundaries: trees (with a gate back to Viridian)
                        if (x === 1 && y === 12) m.push(T.WARP); // Gate tile to Viridian
                        else if (x === 0 || x === 19) m.push(T.TREE);
                        // Exit south (back towards Pallet via Route 1)
                        else if (y === 24 && (x === 9 || x === 10)) m.push(T.WARP);
                        // Paths and grass
                        else if (x === 9 || x === 10) m.push(T.PATH); // Main path
                        else m.push(T.TALL_GRASS); // Lots of tall grass (deterministic)
                    }
                }
                return m;
            })(),
            warps: [
                {x:1, y:12, to: 'viridian', tx: 18, ty: 8},       // Gate back to Viridian
                {x:9, y:24, to: 'route2', tx: 9, ty: 16},         // South exit to Route 2
                {x:10, y:24, to: 'route2', tx: 10, ty: 16}
            ],
            npcs: [], // No NPCs initially in Viridian Forest for chapter 2
            // Encounters for Chapter 2: VS Bulbasaur
            enc: {
                pokemon: [
                    {name: 'RATTATA', spr: 'rattata', lv: [2, 4], rate: 40},
                    {name: 'PIDGEY', spr: 'pidgey', lv: [2, 5], rate: 40},
                    {name: 'BULBASAUR', spr: 'bulbasaur', lv: [5, 7], rate: 20} // Rare encounter for the story
                ],
                rate: 10 // Chance of encounter per step
            }
        },
        player_house: {
            w: 8, h: 8,
            data: (() => {
                const w = 8, h = 8;
                const m = new Array(w * h).fill(T.FLOOR_IN);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || y === 0 || x === w - 1 || y === h - 1) m[y * w + x] = T.WALL_IN;
                }
                m[6 * w + 3] = T.WARP; // door
                // Simple furniture
                m[3 * w + 3] = T.TABLE;
                m[2 * w + 6] = T.SHELF;
                return m;
            })(),
            warps: [{x:3,y:6,to:'pallet_town',tx:4,ty:6}],
            npcs: [{x:5,y:3,name:'Mom',sprite:'mom',dialog:['RED! Go see Professor OAK!','He has something for you!']}],
            enc: null
        },
        
        rival_house: {
            w: 8, h: 8,
            data: (() => {
                const w = 8, h = 8;
                const m = new Array(w * h).fill(T.FLOOR_IN);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || y === 0 || x === w - 1 || y === h - 1) m[y * w + x] = T.WALL_IN;
                }
                m[6 * w + 3] = T.WARP; // door
                m[3 * w + 3] = T.TABLE;
                m[2 * w + 6] = T.SHELF;
                return m;
            })(),
            warps: [{x:3,y:6,to:'pallet_town',tx:14,ty:6}],
            npcs: [{x:2,y:3,name:'Daisy',sprite:'girl',dialog:['Looking for BLUE?','He went to grandpa\'s lab.']}],
            enc: null
        },
        
        oak_lab: {
            w: 10, h: 12,
            data: (() => {
                const w = 10, h = 12;
                const m = new Array(w * h).fill(T.FLOOR_IN);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    if (x === 0 || y === 0 || x === w - 1 || y === h - 1) m[y * w + x] = T.WALL_IN;
                }
                m[11 * w + 4] = T.WARP;
                m[11 * w + 5] = T.WARP;
                // Lab props (clear center aisle).
                m[2 * w + 2] = T.SHELF;
                m[2 * w + 7] = T.SHELF;
                m[5 * w + 2] = T.TABLE;
                m[5 * w + 7] = T.TABLE;
                m[8 * w + 2] = T.TABLE;
                m[8 * w + 7] = T.TABLE;
                return m;
            })(),
            warps: [{x:4,y:11,to:'pallet_town',tx:9,ty:12},{x:5,y:11,to:'pallet_town',tx:9,ty:12}],
            npcs: [{x:5,y:5,name:'Prof. Oak',sprite:'oak',
                // Dynamic dialog based on story state (set in getOakDialog)
                dialog: null
            }],
            enc: null,
            special: 'get_poli'  // Changed from get_pikachu to get_poli (manga accurate!)
        }
    };
    
    // ==================== POKEMON DATA & BATTLE SYSTEM ====================
    const POKEMON_STATS = {
        POLIWHIRL: { baseStats: [50, 65, 50, 65, 90], type: ['WATER'] },
        POLIWRATH: { baseStats: [95, 95, 70, 90, 70], type: ['WATER', 'FIGHTING'] },
        PIKACHU:   { baseStats: [55, 40, 50, 50, 90], type: ['ELECTRIC'] },
        BULBASAUR: { baseStats: [49, 49, 65, 65, 45], type: ['GRASS', 'POISON'] },
        IVYSAUR:   { baseStats: [62, 63, 80, 80, 60], type: ['GRASS', 'POISON'] },
        VENUSAUR:  { baseStats: [82, 83, 100, 100, 80], type: ['GRASS', 'POISON'] },
        RATTATA:   { baseStats: [56, 35, 25, 35, 72], type: ['NORMAL'] },
        RATICATE:  { baseStats: [81, 60, 50, 70, 97], type: ['NORMAL'] },
        PIDGEY:    { baseStats: [45, 40, 35, 35, 56], type: ['NORMAL', 'FLYING'] },
        ONIX:      { baseStats: [45, 160, 30, 45, 70], type: ['ROCK', 'GROUND'] },
        GEODUDE:   { baseStats: [80, 100, 30, 30, 20], type: ['ROCK', 'GROUND'] },
        KOFFING:   { baseStats: [65, 95, 60, 45, 35], type: ['POISON'] },
        ELECTABUZZ:{ baseStats: [93, 57, 95, 85, 105], type: ['ELECTRIC'] },
        GYARADOS:  { baseStats: [125, 79, 60, 100, 81], type: ['WATER', 'FLYING'] },
        STARMIE:   { baseStats: [75, 85, 100, 85, 115], type: ['WATER', 'PSYCHIC'] },
        GENGAR:    { baseStats: [65, 60, 130, 75, 110], type: ['GHOST', 'POISON'] },
        ALAKAZAM:  { baseStats: [55, 50, 135, 95, 120], type: ['PSYCHIC'] },
        MEW:       { baseStats: [100, 100, 100, 100, 100], type: ['PSYCHIC'] },
        MEWTWO:    { baseStats: [110, 90, 154, 90, 130], type: ['PSYCHIC'] },
        DRAGONITE: { baseStats: [134, 95, 100, 100, 80], type: ['DRAGON', 'FLYING'] },
        CHARIZARD: { baseStats: [84, 78, 109, 85, 100], type: ['FIRE', 'FLYING'] },
        STARMIE:   { baseStats: [75, 85, 100, 85, 115], type: ['WATER', 'PSYCHIC'] },
        RAICHU:    { baseStats: [90, 55, 90, 80, 110], type: ['ELECTRIC'] },
        MACHAMP:   { baseStats: [130, 80, 65, 85, 55], type: ['FIGHTING'] },
        HAUNTER:   { baseStats: [45, 45, 115, 55, 95], type: ['GHOST', 'POISON'] },
        ARBOK:     { baseStats: [85, 69, 65, 79, 80], type: ['POISON'] },
        NIDOKING:  { baseStats: [102, 77, 85, 75, 85], type: ['POISON', 'GROUND'] },
        SNORLAX:   { baseStats: [160, 65, 65, 110, 30], type: ['NORMAL'] },
        LAPRAS:    { baseStats: [85, 80, 85, 95, 60], type: ['WATER', 'ICE'] },
        AERODACTYL:{ baseStats: [105, 65, 60, 75, 130], type: ['ROCK', 'FLYING'] },
    };

    const BATTLE_MOVES = {
        'Tackle':        { power: 40, type: 'NORMAL', category: 'Physical' },
        'Scratch':       { power: 40, type: 'NORMAL', category: 'Physical' },
        'Vine Whip':     { power: 45, type: 'GRASS', category: 'Physical' },
        'Razor Leaf':    { power: 55, type: 'GRASS', category: 'Physical' },
        'Solar Beam':    { power: 120, type: 'GRASS', category: 'Special' },
        'Petal Dance':   { power: 120, type: 'GRASS', category: 'Special' },
        'Thunder Shock': { power: 40, type: 'ELECTRIC', category: 'Special' },
        'Thunderbolt':   { power: 90, type: 'ELECTRIC', category: 'Special' },
        'Thunder':       { power: 110, type: 'ELECTRIC', category: 'Special' },
        'Water Gun':     { power: 40, type: 'WATER', category: 'Special' },
        'Hydro Pump':    { power: 110, type: 'WATER', category: 'Special' },
        'Surf':          { power: 90, type: 'WATER', category: 'Special' },
        'Rock Throw':    { power: 50, type: 'ROCK', category: 'Physical' },
        'Bind':          { power: 15, type: 'NORMAL', category: 'Physical' },
        'Psychic':       { power: 90, type: 'PSYCHIC', category: 'Special' },
        'Shadow Ball':   { power: 80, type: 'GHOST', category: 'Special' },
        'Fire Blast':    { power: 110, type: 'FIRE', category: 'Special' },
        'Slash':         { power: 70, type: 'NORMAL', category: 'Physical' },
        'Dig':           { power: 80, type: 'GROUND', category: 'Physical' },
        'Submission':    { power: 80, type: 'FIGHTING', category: 'Physical' },
        'Thrash':        { power: 120, type: 'NORMAL', category: 'Physical' },
        'Dragon Claw':   { power: 80, type: 'DRAGON', category: 'Physical' },
        'Ice Beam':      { power: 90, type: 'ICE', category: 'Special' },
        'Recover':       { power: 0, type: 'PSYCHIC', category: 'Status', effect: 'heal_self' },
        'Hyper Beam':    { power: 150, type: 'NORMAL', category: 'Special' },
        'Earthquake':    { power: 100, type: 'GROUND', category: 'Physical' },
        'Blizzard':      { power: 110, type: 'ICE', category: 'Special' },
        'Body Slam':     { power: 85, type: 'NORMAL', category: 'Physical' },
        'Seismic Toss':  { power: 0, type: 'FIGHTING', category: 'Physical' },
        'Double Edge':   { power: 120, type: 'NORMAL', category: 'Physical' },
        'Wing Attack':   { power: 60, type: 'FLYING', category: 'Physical' },
        'Flamethrower':  { power: 90, type: 'FIRE', category: 'Special' },
        'Sleep Powder':  { power: 0, type: 'GRASS', category: 'Status', effect: 'sleep' }
    };

    const TYPE_CHART = {
        'NORMAL':   { 'ROCK': 0.5, 'GHOST': 0, 'STEEL': 0.5 },
        'FIRE':     { 'WATER': 0.5, 'GRASS': 2, 'ICE': 2, 'BUG': 2, 'ROCK': 0.5, 'DRAGON': 0.5, 'STEEL': 2, 'FIRE': 0.5 },
        'WATER':    { 'FIRE': 2, 'GRASS': 0.5, 'WATER': 0.5, 'DRAGON': 0.5, 'ROCK': 2, 'GROUND': 2 },
        'ELECTRIC': { 'WATER': 2, 'GRASS': 0.5, 'ELECTRIC': 0.5, 'GROUND': 0, 'DRAGON': 0.5, 'FLYING': 2 },
        'GRASS':    { 'FIRE': 0.5, 'WATER': 2, 'GRASS': 0.5, 'GROUND': 2, 'ROCK': 2, 'DRAGON': 0.5, 'BUG': 0.5, 'POISON': 0.5, 'STEEL': 0.5, 'FLYING': 0.5 },
        'ICE':      { 'FIRE': 0.5, 'WATER': 0.5, 'GRASS': 2, 'ICE': 0.5, 'DRAGON': 2, 'GROUND': 2, 'FLYING': 2, 'STEEL': 0.5 },
        'FIGHTING': { 'NORMAL': 2, 'ICE': 2, 'ROCK': 2, 'BUG': 0.5, 'PSYCHIC': 0.5, 'FLYING': 0.5, 'GHOST': 0, 'DARK': 2, 'STEEL': 2, 'POISON': 0.5, 'FAIRY': 0.5 },
        'POISON':   { 'GRASS': 2, 'POISON': 0.5, 'GROUND': 0.5, 'ROCK': 0.5, 'GHOST': 0.5, 'STEEL': 0, 'FAIRY': 2 },
        'GROUND':   { 'FIRE': 2, 'GRASS': 0.5, 'ELECTRIC': 2, 'POISON': 2, 'ROCK': 2, 'BUG': 0.5, 'FLYING': 0, 'STEEL': 2 },
        'FLYING':   { 'GRASS': 2, 'FIGHTING': 2, 'BUG': 2, 'ELECTRIC': 0.5, 'ROCK': 0.5, 'STEEL': 0.5 },
        'PSYCHIC':  { 'FIGHTING': 2, 'PSYCHIC': 0.5, 'POISON': 2, 'DARK': 0, 'STEEL': 0.5 },
        'BUG':      { 'FIRE': 0.5, 'FIGHTING': 0.5, 'FLYING': 0.5, 'POISON': 0.5, 'GHOST': 0.5, 'STEEL': 0.5, 'DARK': 2, 'GRASS': 2, 'PSYCHIC': 2, 'FAIRY': 0.5 },
        'ROCK':     { 'FIRE': 2, 'FIGHTING': 0.5, 'FLYING': 2, 'BUG': 2, 'ICE': 2, 'GROUND': 0.5, 'STEEL': 0.5 },
        'GHOST':    { 'NORMAL': 0, 'PSYCHIC': 2, 'GHOST': 2, 'DARK': 0.5 },
        'DRAGON':   { 'DRAGON': 2, 'STEEL': 0.5, 'FAIRY': 0 },
        'DARK':     { 'FIGHTING': 0.5, 'PSYCHIC': 2, 'GHOST': 2, 'DARK': 0.5, 'FAIRY': 0.5 },
        'STEEL':    { 'FIRE': 0.5, 'WATER': 0.5, 'ELECTRIC': 0.5, 'ICE': 2, 'ROCK': 2, 'FAIRY': 2, 'STEEL': 0.5 },
        'FAIRY':    { 'FIRE': 0.5, 'FIGHTING': 2, 'POISON': 0.5, 'DRAGON': 2, 'DARK': 2, 'STEEL': 0.5 }
    };

    function getTypeMultiplier(atkType, defTypes) {
        let mult = 1;
        const chart = TYPE_CHART[atkType];
        if (!chart) return 1;
        for (const dt of defTypes) {
            mult *= (chart[dt] !== undefined ? chart[dt] : 1);
        }
        return mult;
    }

    function calcBattleDamage(attacker, defender, moveName) {
        const move = BATTLE_MOVES[moveName];
        if (!move || move.power === 0) return 0;
        
        const atkStats = POKEMON_STATS[attacker.species] || { baseStats: [50,50,50,50,50], type: ['NORMAL'] };
        const defStats = POKEMON_STATS[defender.species] || { baseStats: [50,50,50,50,50], type: ['NORMAL'] };
        
        const atkLv = attacker.lv || 10;
        const atkStat = move.category === 'Physical' ? atkStats.baseStats[0] : atkStats.baseStats[2];
        const defStat = move.category === 'Physical' ? defStats.baseStats[1] : defStats.baseStats[3];
        
        let dmg = ((2 * atkLv / 5 + 2) * move.power * atkStat / defStat / 50) + 2;
        dmg *= getTypeMultiplier(move.type, defStats.type);
        
        // STAB bonus
        if (atkStats.type.includes(move.type)) dmg *= 1.5;
        
        // Random variance (85-100%)
        dmg *= (0.85 + Math.random() * 0.15);
        
        return Math.max(1, Math.floor(dmg));
    }

    // ==================== GAME STATE ====================
    let GS = {
        px: 9, py: 13, dir: 'down',
        map: 'pallet_town',
        // MANGA STORY FLAGS (Pokémon Adventures - Red Chapter)
        story: {
            season: 1,
            beat: 'ch1_intro',
            chapter: 1,           // Current chapter (VS Mew, VS Bulbasaur, etc)
            sawMew: false,        // Ch1: Red saw Mew in the forest
            talkedToOak: false,   // Ch1: Talked to Prof Oak first time
            gotPokedex: false,    // Ch1: Received Pokedex from Oak
            gotSaur: false,       // Ch1: Received Bulbasaur (SAUR) from Oak
            metBlue: false,       // Ch1: Met Blue (rival)
            metGreen: false,      // Ch3: Met Green (the thief girl)
            defeatedRocket1: false, // Ch3: First Team Rocket encounter
            caughtBulba: false,   // Ch2: Caught Bulbasaur
            caughtPika: false,    // Ch4: Caught Pikachu in Pewter
            brockBattleDone: false, // Ch4: First clash with Brock
        },
        // Party (manga starts with Poliwhirl, not Pikachu!)
        team: [],
        poli: {name: 'POLI', species: 'POLIWHIRL', hp: 28, maxHp: 28, lv: 8, exp: 0, spr: 'poliwhirl'},
        pika: {name: 'PIKA', species: 'PIKACHU', hp: 20, maxHp: 20, lv: 6, exp: 0, spr: 'pikachuBattle'},
        items: {potion: 3, pokeball: 5}
    };
    
    let dialog = null;
    let dialogQ = [];
    let inBattle = false;
    let battle = null;
    let moveInt = null;
    let moveDir = null;
    let animFrame = 0;
    let dialogAutoTimer = 0;

    // ==================== STORY SCRIPT ====================
    let STORY = null;
    let storyLoadPromise = null;
    let activeBeatId = null;
    let cutsceneLock = false;
    let actionProgressAt = Date.now();
    let renderLoopActive = false;
    let renderLoopToken = 0;
    let renderRafId = 0;
    let storyMoveTimer = 0;
    let storyMoveToken = 0;
    let currentCollisionMapId = '';
    let currentCollisionGrid = null;
    let currentCollisionW = 0;
    let currentCollisionH = 0;
    const DIALOG_PORTRAIT_SPEAKER_MAP = {
        'BULBASAUR': 'bulbasaur',
        'SAUR': 'bulbasaur',
        'POLI': 'poliwhirl',
        'POLIWHIRL': 'poliwhirl',
        'PIKACHU': 'pikachuBattle',
        'MEW': 'mew',
        'CHARMANDER': 'charmander'
    };

    function dialogPortraitKeyFor(speaker, line) {
        const s = String(speaker || '').trim().toUpperCase();
        if (s && DIALOG_PORTRAIT_SPEAKER_MAP[s]) return DIALOG_PORTRAIT_SPEAKER_MAP[s];
        const t = String(line || '').toUpperCase();
        if (t.includes('BULBASAUR') || t.includes('SAUR')) return 'bulbasaur';
        if (t.includes('PIKACHU')) return 'pikachuBattle';
        if (t.includes('MEW')) return 'mew';
        return '';
    }

    function cancelStoryMove() {
        storyMoveToken++;
        if (storyMoveTimer) {
            clearTimeout(storyMoveTimer);
            storyMoveTimer = 0;
        }
    }

    function hideRuntimeOverlays() {
        const dialogBox = document.getElementById('dialogBox');
        const tapOverlay = document.getElementById('tapOverlay');
        const battleScreen = document.getElementById('battleScreen');
        if (dialogBox) dialogBox.style.display = 'none';
        if (tapOverlay) tapOverlay.style.display = 'none';
        if (battleScreen) battleScreen.style.display = 'none';
    }

    function clearDialogAutoAdvance() {
        if (dialogAutoTimer) {
            clearTimeout(dialogAutoTimer);
            dialogAutoTimer = 0;
        }
    }

    function scheduleDialogAutoAdvance() {
        clearDialogAutoAdvance();
        // Failsafe: only for scripted cutscenes (not free NPC chat).
        if (!AUTO_DIALOG_ADVANCE) return;
        if (!cutsceneLock || !dialog) return;
        const dialogRef = dialog;
        dialogAutoTimer = setTimeout(() => {
            if (!dialog || dialog !== dialogRef) return;
            try { nextDialog(); } catch {}
        }, 2600);
    }

    function clearOrphanRuntimeLocks() {
        const dialogBox = document.getElementById('dialogBox');
        const tapOverlay = document.getElementById('tapOverlay');
        const battleScreen = document.getElementById('battleScreen');
        const dialogVisible = !!(dialogBox && dialogBox.style.display !== 'none');
        const overlayVisible = !!(tapOverlay && tapOverlay.style.display !== 'none');
        const battleVisible = !!(battleScreen && battleScreen.style.display !== 'none');

        // If UI is visible but dialog state was lost, close stale UI to avoid soft-lock.
        if (!dialog && dialogVisible) {
            dialogBox.style.display = 'none';
        }
        // Never null-out dialog just because queue is empty: the final "tap to continue"
        // must still execute nextDialog() and invoke the callback chain.
        if (dialog && Array.isArray(dialogQ) && dialogQ.length === 0 && !dialogVisible && !overlayVisible) {
            try { nextDialog(); } catch {}
        }
        if (dialog && dialogVisible && !overlayVisible) {
            // Keep interaction layer aligned with visible dialog.
            tapOverlay.style.display = 'block';
        }
        if (dialog && !dialogVisible && !overlayVisible) {
            // Dialog state exists but UI vanished: restore the same visible step.
            // Never auto-advance here (can cause race/skip/freeze on mobile event storms).
            dialogBox.style.display = 'block';
            tapOverlay.style.display = 'block';
        }
        if (!dialog && !inBattle && overlayVisible) {
            tapOverlay.style.display = 'none';
        }
        if (inBattle && !battleVisible && (!battle || !battle.pending)) {
            inBattle = false;
            battle = null;
        }
        if (cutsceneLock && activeBeatId && !dialog && !inBattle && !moveInt) {
            // Recovery for rare broken action chain: no visible step progressing.
            if (Date.now() - actionProgressAt > 3200) {
                activeBeatId = null;
                cutsceneLock = false;
            }
        }
        if (cutsceneLock && !activeBeatId && !dialog && !inBattle) {
            cutsceneLock = false;
        }
        if (activeBeatId && !cutsceneLock && !dialog && !inBattle) {
            activeBeatId = null;
        }
    }

    const SceneManager = {
        currentScene: null,
        clearRenderLayer() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        },
        unloadScene(opts = {}) {
            const preserveFlow = !!opts.preserveFlow;
            stopMove();
            cancelStoryMove();
            this.clearRenderLayer();
            setSceneBackdrop('');
            if (!preserveFlow) {
                dialog = null;
                dialogQ = [];
                inBattle = false;
                battle = null;
                activeBeatId = null;
                cutsceneLock = false;
                hideRuntimeOverlays();
            }
            this.currentScene = null;
        },
        loadScene(mapId) {
            this.currentScene = mapId;
            this.clearRenderLayer();
            loadCollisionGrid(mapId);
        }
    };

    function normalizeAssetPath(v) {
        if (!v || typeof v !== 'string') return '';
        return v.replace(/\\/g, '/').replace(/^\.\//, '');
    }

    function mapBgUrlForMap(mapId) {
        const conf = PREBUILT_MAP_BG_CONFIG && PREBUILT_MAP_BG_CONFIG[mapId];
        return conf && typeof conf.url === 'string' ? conf.url : '';
    }

    function hasSceneBackdrop() {
        const el = document.getElementById('sceneBackdrop');
        if (!el) return false;
        return el.style.display !== 'none' && !!el.style.backgroundImage;
    }

    function loadCollisionGrid(mapId) {
        const map = MAPS[mapId];
        if (!map || !Array.isArray(map.data) || !map.w || !map.h) {
            currentCollisionMapId = '';
            currentCollisionGrid = null;
            currentCollisionW = 0;
            currentCollisionH = 0;
            return;
        }
        const total = map.w * map.h;
        const grid = new Uint8Array(total);
        for (let i = 0; i < total; i++) {
            const tile = map.data[i];
            grid[i] = SOLID.includes(tile) ? 1 : 0;
        }

        // Optional per-map collision overrides from mapbg manifest (tile coordinates).
        const conf = PREBUILT_MAP_BG_CONFIG && PREBUILT_MAP_BG_CONFIG[mapId];
        const rects = conf && Array.isArray(conf.solidRects) ? conf.solidRects : [];
        for (const r of rects) {
            const rx = Number(r && r.x);
            const ry = Number(r && r.y);
            const rw = Number(r && r.w);
            const rh = Number(r && r.h);
            if (!Number.isFinite(rx) || !Number.isFinite(ry) || !Number.isFinite(rw) || !Number.isFinite(rh)) continue;
            for (let y = ry; y < ry + rh; y++) {
                for (let x = rx; x < rx + rw; x++) {
                    if (x >= 0 && y >= 0 && x < map.w && y < map.h) {
                        grid[y * map.w + x] = 1;
                    }
                }
            }
        }

        currentCollisionMapId = mapId;
        currentCollisionGrid = grid;
        currentCollisionW = map.w;
        currentCollisionH = map.h;
    }

    async function loadStory(force = false) {
        if (!force && storyLoadPromise) return storyLoadPromise;
        storyLoadPromise = (async () => {
            // Prefer bundled local story payload (works even when fetch/cache is flaky).
            try {
                const inlineStory = (typeof window !== 'undefined' && window.__POKEMON_STORY__) ? window.__POKEMON_STORY__ : null;
                if (inlineStory && Array.isArray(inlineStory.beats) && inlineStory.beats.length > 0) {
                    STORY = inlineStory;
                    return STORY;
                }
            } catch {}
            try {
                const res = await fetch('./story/season1.ptbr.json', {cache: 'no-store'});
                if (!res.ok) throw new Error('story fetch failed');
                STORY = await res.json();
            } catch (e) {
                console.warn('Failed to load story JSON. Falling back to inline story.', e);
                STORY = null;
            }
            return STORY;
        })();
        return storyLoadPromise;
    }

    async function ensureStoryLoaded() {
        if (STORY && STORY.beats) return STORY;
        return loadStory(false);
    }

    function getBeat(id) {
        const beats = STORY && STORY.beats ? STORY.beats : null;
        if (!beats) return null;
        return beats.find(b => b && b.id === id) || null;
    }

    function getByPath(root, path) {
        const parts = String(path || '').split('.').filter(Boolean);
        let cur = root;
        for (const p of parts) {
            if (!cur || typeof cur !== 'object') return undefined;
            cur = cur[p];
        }
        return cur;
    }

    function setByPath(root, path, value) {
        const parts = String(path || '').split('.').filter(Boolean);
        if (parts.length === 0) return;
        let cur = root;
        for (let i = 0; i < parts.length - 1; i++) {
            const p = parts[i];
            if (!cur[p] || typeof cur[p] !== 'object') cur[p] = {};
            cur = cur[p];
        }
        cur[parts[parts.length - 1]] = value;
    }

    function ensureTeam(ids) {
        const want = Array.isArray(ids) ? ids : [];
        const next = [];
        for (const id of want) {
            if (id === 'poli') next.push(GS.poli);
            if (id === 'saur') next.push(GS.saur);
            if (id === 'pika') next.push(GS.pika);
        }
        if (next.length) GS.team = next;
    }

    function evolveMon(slot, toSpecies, opts = {}) {
        const key = String(slot || '').toLowerCase();
        const ref = key === 'poli' ? GS.poli : key === 'saur' ? GS.saur : key === 'pika' ? GS.pika : null;
        if (!ref) return false;
        const species = String(toSpecies || '').toUpperCase();
        if (!species) return false;
        
        // Visual evolution effect
        const overlay = document.getElementById('evolutionOverlay');
        const canvas = document.getElementById('gameCanvas');
        if (overlay && canvas) {
            overlay.classList.add('active');
            canvas.classList.add('evolving');
            setTimeout(() => {
                overlay.classList.remove('active');
                canvas.classList.remove('evolving');
            }, 1500);
        }
        
        // Update Pokemon data
        const oldSpecies = ref.species;
        ref.species = species;
        if (typeof opts.name === 'string' && opts.name.trim()) ref.name = opts.name.trim().toUpperCase();
        if (typeof opts.lv === 'number') ref.lv = Math.max(ref.lv, opts.lv);
        
        // Boost stats on evolution
        const hpBoost = species === 'IVYSAUR' ? 15 : species === 'VENUSAUR' ? 25 : species === 'POLIWRATH' ? 20 : 10;
        ref.maxHp = Math.max(ref.maxHp, ref.maxHp + hpBoost);
        ref.hp = ref.maxHp; // Full heal on evolution
        
        console.log(`🌟 ${ref.name} evolved from ${oldSpecies} to ${species}!`);
        return true;
    }

    function runMovePath(path, stepMs, onDone) {
        const dirs = Array.isArray(path) ? path.filter(Boolean) : [];
        const delay = Math.max(40, Number(stepMs) || 120);
        const token = ++storyMoveToken;
        let i = 0;
        function step() {
            if (token !== storyMoveToken) {
                storyMoveTimer = 0;
                return;
            }
            if (i >= dirs.length) {
                storyMoveTimer = 0;
                if (typeof onDone === 'function') onDone();
                return;
            }
            const d = String(dirs[i++]);
            let nx = GS.px, ny = GS.py;
            if (d === 'up') ny--;
            else if (d === 'down') ny++;
            else if (d === 'left') nx--;
            else if (d === 'right') nx++;
            if (canMove(nx, ny)) {
                GS.dir = d;
                GS.px = nx;
                GS.py = ny;
            }
            storyMoveTimer = setTimeout(step, delay);
        }
        step();
    }

    function runActions(actions, idx = 0, onDone = null) {
        actionProgressAt = Date.now();
        const list = Array.isArray(actions) ? actions : [];
        if (idx >= list.length) {
            if (typeof onDone === 'function') onDone();
            return;
        }
        const a = list[idx];
        if (!a || typeof a !== 'object') return runActions(list, idx + 1, onDone);

        try {
            if (a.kind === 'dialog') {
                showDialog(a.speaker || '', Array.isArray(a.lines) ? a.lines : ['...'], () => runActions(list, idx + 1, onDone));
                return;
            }
            if (a.kind === 'set') {
                setByPath(GS, a.path, a.value);
                scheduleSave('story-set');
                return runActions(list, idx + 1, onDone);
            }
            if (a.kind === 'face') {
                if (a.dir) GS.dir = String(a.dir);
                return runActions(list, idx + 1, onDone);
            }
            if (a.kind === 'pause') {
                const ms = Math.max(0, Number(a.ms) || 250);
                setTimeout(() => runActions(list, idx + 1, onDone), ms);
                return;
            }
        if (a.kind === 'move') {
            if (!AUTO_CUTSCENE_MOVE) {
                // Skip forced auto-walk by default to avoid perceived input-loss/auto-run on iPad.
                const dirs = Array.isArray(a.path) ? a.path : [];
                if (dirs.length) GS.dir = String(dirs[dirs.length - 1]);
                setTimeout(() => runActions(list, idx + 1, onDone), Math.max(40, Number(a.stepMs) || 120));
                return;
            }
            runMovePath(a.path, a.stepMs, () => {
                scheduleSave('story-move');
                runActions(list, idx + 1, onDone);
            });
            return;
        }
            if (a.kind === 'teleport') {
                if (a.map && MAPS[a.map]) GS.map = a.map;
                if (typeof a.x === 'number') GS.px = a.x;
                if (typeof a.y === 'number') GS.py = a.y;
                if (a.dir) GS.dir = String(a.dir);
                // Load collision grid BEFORE checking walkable position
                onMapEnter(GS.map, {preserveFlow: true});
                ensureWalkablePlayerPosition();
                scheduleSave('story-teleport');
                return runActions(list, idx + 1, onDone);
            }
            if (a.kind === 'ensureTeam') {
                ensureTeam(a.value);
                scheduleSave('story-team');
                return runActions(list, idx + 1, onDone);
            }
            if (a.kind === 'evolve') {
                evolveMon(a.slot, a.to, a.options && typeof a.options === 'object' ? a.options : {});
                scheduleSave('story-evolve');
                return runActions(list, idx + 1, onDone);
            }
            if (a.kind === 'battle') {
                const enemy = a.enemy && typeof a.enemy === 'object'
                    ? a.enemy
                    : {name: 'PIDGEY', spr: 'pidgey', lv: 4, hp: 18, maxHp: 18};
                const opts = a.options && typeof a.options === 'object' ? a.options : {};
                const nextOnEnd = opts.onEnd;
                startBattle(enemy, {
                    ...opts,
                    scripted: opts.scripted !== false,
                    onEnd: (won) => {
                        try {
                            if (nextOnEnd === 'only_if_win' && !won) {
                                // Fail-safe: never deadlock story/input if scripted battle is lost.
                                const active = getActivePokemon();
                                active.hp = Math.max(1, Math.floor(active.maxHp * 0.5));
                                showDialog('', ['Voce recua por um instante, mas continua.'], () => {
                                    runActions(list, idx + 1, onDone);
                                });
                                return;
                            }
                            runActions(list, idx + 1, onDone);
                        } catch (err) {
                            dbg(`battle onEnd error: ${err && err.message ? err.message : String(err)}`);
                            runActions(list, idx + 1, onDone);
                        }
                    }
                });
                return;
            }
            // Unknown action: skip
            runActions(list, idx + 1, onDone);
        } catch (err) {
            dbg(`runActions error @${idx}: ${err && err.message ? err.message : String(err)}`);
            setTimeout(() => runActions(list, idx + 1, onDone), 0);
        }
    }

    function playBeat(id) {
        if (activeBeatId === id) return true;
        if (activeBeatId && activeBeatId !== id) return false;
        const beat = getBeat(id);
        if (!beat) return false;
        // Prevent residual movement timers from carrying into cutscenes.
        stopMove();
        cancelStoryMove();
        const beatBg = beatBackdropFor(id);
        const mapBg = mapBgUrlForMap(GS.map);
        // Avoid visual ghosting: don't stack identical map sheet as both mapbg and scene backdrop.
        if (normalizeAssetPath(beatBg) && normalizeAssetPath(beatBg) !== normalizeAssetPath(mapBg)) {
            setSceneBackdrop(beatBg);
        } else {
            setSceneBackdrop('');
        }
        cutsceneLock = true;
        activeBeatId = id;
        GS.story.beat = id;
        runActions(beat.actions, 0, () => {
            cancelStoryMove();
            if (activeBeatId === id) activeBeatId = null;
            cutsceneLock = false;
            scheduleSave('beat');
            // Ensure intro always chains into Oak's lab beat even if map-enter hook timing is missed.
            if (id === 'ch1_intro' && GS.story && GS.story.sawMew && !GS.story.gotSaur) {
                if (GS.map !== 'oak_lab') {
                    GS.map = 'oak_lab';
                    GS.px = 5;
                    GS.py = 9;
                    GS.dir = 'up';
                    ensureWalkablePlayerPosition();
                    onMapEnter(GS.map, {preserveFlow: true});
                }
                setTimeout(() => {
                    if (!activeBeatId && !inBattle && !dialog && GS.story && GS.story.sawMew && !GS.story.gotSaur) {
                        playBeat('ch1_oak_mew_explain');
                    }
                }, 180);
                return;
            }
            // If beat has releaseControl flag, let player explore instead of auto-chaining
            if (beat.releaseControl) {
                // Player gets free control - don't auto-chain to next beat
                return;
            }
            // Continue chaining story automatically when multiple beats belong to the same area.
            setTimeout(() => { tryAutoStoryBeat(); }, 220);
        });
        return true;
    }
    
    // ==================== ASSET LOADING ====================
    function createTilesetCanvas() {
        // Tile atlas: 8 columns x 4 rows. Each tile is 16x16.
        // Original pixel art tiles inspired by the FRLG feel (no ripped assets).
        const cols = 8;
        const rows = 4;
        const ts = document.createElement('canvas');
        ts.width = cols * TILE;
        ts.height = rows * TILE;
        const tctx = ts.getContext('2d');

        function px(x, y, w, h, color) {
            tctx.fillStyle = color;
            tctx.fillRect(x, y, w, h);
        }

        function dither(x0, y0, a, b) {
            for (let y = 0; y < TILE; y++) {
                for (let x = 0; x < TILE; x++) {
                    tctx.fillStyle = ((x + y) % 2 === 0) ? a : b;
                    tctx.fillRect(x0 + x, y0 + y, 1, 1);
                }
            }
        }

        function speckle(x0, y0, color, n) {
            tctx.fillStyle = color;
            for (let i = 0; i < n; i++) {
                const x = x0 + ((i * 7) % TILE);
                const y = y0 + ((i * 11) % TILE);
                tctx.fillRect(x, y, 1, 1);
            }
        }

        function tile(ax, ay, drawFn) {
            const x0 = ax * TILE;
            const y0 = ay * TILE;
            drawFn(x0, y0);
        }

        // Row 0: ground
        tile(0, 0, (x0, y0) => { dither(x0, y0, C.grass, C.grass2); speckle(x0, y0, C.grass3, 18); }); // GRASS
        tile(1, 0, (x0, y0) => { dither(x0, y0, C.path, C.path2); speckle(x0, y0, C.path3, 14); });     // PATH
        tile(2, 0, (x0, y0) => { // WATER
            px(x0, y0, TILE, TILE, C.water);
            for (let y = 2; y < TILE; y += 4) {
                for (let x = 0; x < TILE; x++) {
                    const c = (x % 6 < 3) ? C.water2 : C.water3;
                    tctx.fillStyle = c;
                    tctx.fillRect(x0 + x, y0 + y, 1, 1);
                }
            }
        });
        tile(3, 0, (x0, y0) => { dither(x0, y0, C.grass2, C.grass3); for (let x = 1; x < TILE; x += 3) px(x0 + x, y0 + 2, 1, 12, C.grass); }); // TALL_GRASS
        tile(4, 0, (x0, y0) => { // TREE
            px(x0, y0, TILE, TILE, C.tree2);
            px(x0 + 1, y0 + 1, TILE - 2, TILE - 2, C.tree);
            px(x0 + 7, y0 + 11, 2, 4, C.trunk);
            px(x0 + 3, y0 + 3, 2, 2, C.grass);
        });
        tile(5, 0, (x0, y0) => { // FENCE
            dither(x0, y0, C.fence, C.fence2);
            px(x0 + 1, y0 + 5, TILE - 2, 1, C.shadow);
            px(x0 + 1, y0 + 10, TILE - 2, 1, C.shadow);
            for (let x = 2; x < TILE; x += 4) px(x0 + x, y0 + 2, 1, 12, C.shadow);
        });
        tile(6, 0, (x0, y0) => { // SIGN
            dither(x0, y0, C.grass, C.grass2);
            px(x0 + 3, y0 + 3, 10, 6, C.wall);
            px(x0 + 4, y0 + 4, 8, 4, C.wall2);
            px(x0 + 7, y0 + 9, 2, 6, C.sign);
        });
        tile(7, 0, (x0, y0) => { dither(x0, y0, C.grass, C.grass2); px(x0 + 7, y0 + 7, 2, 2, C.flower); px(x0 + 6, y0 + 8, 1, 1, '#fff'); px(x0 + 9, y0 + 6, 1, 1, '#fff'); }); // FLOWER

        // Row 1: building palette (roof/wall/door/window + interiors)
        tile(0, 1, (x0, y0) => { dither(x0, y0, C.roofR, C.roofR2); }); // ROOF_RED
        tile(1, 1, (x0, y0) => { dither(x0, y0, C.roofB, C.roofB2); }); // ROOF_BLUE
        tile(2, 1, (x0, y0) => { dither(x0, y0, C.roofG, C.roofG2); }); // ROOF_LAB
        tile(3, 1, (x0, y0) => { dither(x0, y0, C.wall, C.wall2); });   // WALL
        tile(4, 1, (x0, y0) => { // DOOR
            dither(x0, y0, C.wall, C.wall2);
            px(x0 + 5, y0 + 4, 6, 10, '#7b4b1b');
            px(x0 + 6, y0 + 5, 4, 8, '#925b22');
            px(x0 + 9, y0 + 9, 1, 1, '#f6e05e');
        });
        tile(5, 1, (x0, y0) => { // WINDOW
            dither(x0, y0, C.wall, C.wall2);
            px(x0 + 4, y0 + 4, 8, 6, '#9bd6ff');
            px(x0 + 4, y0 + 4, 8, 1, C.shadow);
            px(x0 + 4, y0 + 9, 8, 1, C.shadow);
            px(x0 + 4, y0 + 4, 1, 6, C.shadow);
            px(x0 + 11, y0 + 4, 1, 6, C.shadow);
        });
        tile(6, 1, (x0, y0) => { // FLOOR_IN
            dither(x0, y0, '#d9c39a', '#cfb487');
            speckle(x0, y0, '#b99563', 10);
        });
        tile(7, 1, (x0, y0) => { // WALL_IN
            px(x0, y0, TILE, TILE, '#c6b18a');
            px(x0, y0, TILE, 2, '#ad976e');
            px(x0, y0 + 2, TILE, 1, '#bda57a');
        });

        // Row 2: WARP marker (subtle)
        tile(0, 2, (x0, y0) => {
            dither(x0, y0, C.path, C.path2);
            px(x0 + 4, y0 + 4, 8, 8, '#111827');
            px(x0 + 5, y0 + 5, 6, 6, '#1f2937');
            px(x0 + 7, y0 + 7, 2, 2, '#9ca3af');
        });

        // Row 2+: variants to break repetition (deterministic noise picks)
        tile(1, 2, (x0, y0) => { dither(x0, y0, C.grass2, C.grass); speckle(x0, y0, C.grass3, 26); }); // GRASS_ALT
        tile(2, 2, (x0, y0) => { dither(x0, y0, C.path2, C.path); speckle(x0, y0, C.path3, 22); });     // PATH_ALT

        // Row 3: simple interior props (original)
        tile(0, 3, (x0, y0) => { // TABLE
            px(x0, y0, TILE, TILE, '#d9c39a');
            px(x0 + 2, y0 + 4, 12, 8, '#8b5a2b');
            px(x0 + 3, y0 + 5, 10, 6, '#a0672f');
            px(x0 + 3, y0 + 12, 2, 3, '#6b3f1a');
            px(x0 + 11, y0 + 12, 2, 3, '#6b3f1a');
        });
        tile(1, 3, (x0, y0) => { // SHELF
            px(x0, y0, TILE, TILE, '#d9c39a');
            px(x0 + 2, y0 + 2, 12, 12, '#7b4b1b');
            px(x0 + 3, y0 + 3, 10, 2, '#925b22');
            px(x0 + 3, y0 + 7, 10, 2, '#925b22');
            px(x0 + 3, y0 + 11, 10, 2, '#925b22');
            // books
            px(x0 + 4, y0 + 4, 1, 2, '#ef4444');
            px(x0 + 6, y0 + 4, 1, 2, '#3b82f6');
            px(x0 + 8, y0 + 4, 1, 2, '#22c55e');
        });

        return ts;
    }

    function qs(name, dflt = '') {
        try { return (new URLSearchParams(location.search)).get(name) || dflt; }
        catch { return dflt; }
    }

    function normalizeUrl(v) {
        try {
            if (!v) return '';
            return new URL(String(v), location.href).toString();
        } catch {
            return '';
        }
    }

    function mapBattleTerrain(mapId) {
        if (!mapId) return BATTLE_TERRAIN_URLS.grass;
        if (mapId.includes('gym') || mapId.includes('house') || mapId === 'oak_lab' || mapId === 'silph_lobby') return BATTLE_TERRAIN_URLS.building;
        if (mapId.includes('forest')) return BATTLE_TERRAIN_URLS.longgrass;
        if (mapId.includes('moon') || mapId.includes('cave')) return BATTLE_TERRAIN_URLS.cave;
        if (mapId.includes('pewter') || mapId.includes('indigo') || mapId.includes('route3')) return BATTLE_TERRAIN_URLS.mountain;
        if (mapId.includes('cinnabar')) return BATTLE_TERRAIN_URLS.water;
        if (mapId.includes('cerulean') || mapId.includes('fuchsia')) return BATTLE_TERRAIN_URLS.pond;
        return BATTLE_TERRAIN_URLS.grass;
    }

    function mapTrainerSpriteKey(name) {
        const n = String(name || '').toLowerCase();
        if (n.includes('blue') || n.includes('rival')) return 'trainerBlue';
        if (n.includes('brock')) return 'trainerBrock';
        if (n.includes('rocket') || n.includes('grunt')) return 'trainerRocket';
        if (n.includes('giovanni')) return 'trainerGiovanni';
        if (n.includes('lance')) return 'trainerLance';
        if (n.includes('oak')) return 'trainerOak';
        return '';
    }

    function inferTrainerByBeat() {
        const id = String(activeBeatId || GS?.story?.beat || '').toLowerCase();
        if (!id) return {name: '', sprite: ''};
        if (id.includes('brock')) return {name: 'Brock', sprite: 'trainerBrock'};
        if (id.includes('rocket')) return {name: 'Team Rocket', sprite: 'trainerRocket'};
        if (id.includes('giovanni')) return {name: 'Giovanni', sprite: 'trainerGiovanni'};
        if (id.includes('lance')) return {name: 'Lance', sprite: 'trainerLance'};
        if (id.includes('blue') || id.includes('champion') || id.includes('duel')) return {name: 'Blue', sprite: 'trainerBlue'};
        if (id.includes('oak')) return {name: 'Prof. Oak', sprite: 'trainerOak'};
        return {name: '', sprite: ''};
    }

    let bannerTimer = null;
    function showMapBanner(mapId) {
        const el = document.getElementById('mapBanner');
        if (!el) return;
        const title = MAP_LABELS[mapId] || mapId || '';
        if (!title) return;
        el.textContent = title;
        el.style.display = 'block';
        if (bannerTimer) clearTimeout(bannerTimer);
        bannerTimer = setTimeout(() => { el.style.display = 'none'; }, 1400);
    }

    function beatBackdropFor(id) {
        const b = String(id || '').toLowerCase();
        if (!b) return SCENE_BACKDROP_DEFAULT || '';
        for (const rule of SCENE_BACKDROP_RULES) {
            try {
                const rx = new RegExp(rule.match, 'i');
                if (rx.test(b)) return rule.url;
            } catch {
                // Ignore malformed optional rule.
            }
        }
        return SCENE_BACKDROP_DEFAULT || '';
    }

    function setSceneBackdrop(url) {
        const el = document.getElementById('sceneBackdrop');
        if (!el) return;
        if (!url) {
            el.style.display = 'none';
            el.style.backgroundImage = '';
            return;
        }
        el.style.backgroundImage = `url('${url}')`;
        el.style.display = 'block';
    }

    function applyVisualSkin() {
        const continueEl = document.querySelector('#dialogBox .continue');
        if (continueEl) {
            continueEl.style.backgroundImage = `url('${UI_SKIN_URLS.arrow}')`;
        }
        const menuEl = document.getElementById('battleMenu');
        const logEl = document.getElementById('battleLog');
        const okEl = document.getElementById('battleOk');
        if (menuEl) {
            menuEl.style.backgroundImage = `linear-gradient(rgba(255,255,255,0.88), rgba(255,255,255,0.88)), url('${UI_SKIN_URLS.menu}')`;
            menuEl.style.backgroundSize = 'cover';
        }
        if (logEl) {
            logEl.style.backgroundImage = `linear-gradient(rgba(248,250,252,0.92), rgba(248,250,252,0.92)), url('${UI_SKIN_URLS.log}')`;
            logEl.style.backgroundSize = 'cover';
        }
        if (okEl) {
            okEl.style.backgroundImage = `linear-gradient(rgba(255,255,255,0.9), rgba(255,255,255,0.9)), url('${UI_SKIN_URLS.ok}')`;
            okEl.style.backgroundSize = 'cover';
        }
        const buttons = document.querySelectorAll('.battle-menu button, .battle-ok button, .back-btn');
        buttons.forEach((btn) => {
            btn.style.backgroundImage = `linear-gradient(rgba(255,255,255,0.08), rgba(255,255,255,0.08)), url('${UI_SKIN_URLS.selectBtn}')`;
            btn.style.backgroundSize = 'cover';
            btn.style.backgroundPosition = 'center';
        });
        const bagBtn = document.querySelector('.battle-menu .bag');
        if (bagBtn) {
            bagBtn.style.backgroundImage = `linear-gradient(rgba(245,158,11,0.18), rgba(245,158,11,0.18)), url('${UI_SKIN_URLS.bag}')`;
            bagBtn.style.backgroundSize = 'cover';
            bagBtn.style.backgroundPosition = 'center';
        }
        const hpBars = document.querySelectorAll('.hp-bar');
        hpBars.forEach((bar) => {
            bar.style.backgroundImage = "url('./assets/tilesets/interface/hp_bar_anim.png')";
            bar.style.backgroundSize = 'cover';
            bar.style.backgroundRepeat = 'no-repeat';
        });
    }

    function applyBattleVisuals(enemy, opts = {}) {
        const bf = document.getElementById('battleField');
        if (bf) {
            const terrainUrl = mapBattleTerrain(GS.map);
            bf.style.backgroundImage = `linear-gradient(rgba(0,0,0,0.18), rgba(0,0,0,0.18)), url('${terrainUrl}')`;
        }
        const portraitEl = document.getElementById('trainerPortrait');
        if (!portraitEl) return;
        const byBeat = inferTrainerByBeat();
        const trainerKey = opts.trainerSprite || mapTrainerSpriteKey(opts.trainerName || enemy.trainer || byBeat.name) || byBeat.sprite;
        if (!trainerKey || !SPRITE_URLS[trainerKey]) {
            portraitEl.style.display = 'none';
            portraitEl.src = '';
            return;
        }
        portraitEl.src = SPRITE_URLS[trainerKey];
        portraitEl.style.display = 'block';
    }

    async function tryLoadExternalSpriteConfig() {
        // Strict local mode: only project assets are accepted.
        const jsonUrl = './assets/sprites/user.sprites.json';
        try {
            const res = await fetch(jsonUrl, {cache: 'no-store'});
            if (!res.ok) return {};
            const cfg = await res.json();
            const incoming = cfg && typeof cfg === 'object' ? (cfg.sprites || cfg) : {};
            if (!incoming || typeof incoming !== 'object') return {};

            function asLocal(v) {
                if (typeof v !== 'string' || !v.trim()) return '';
                const raw = normalizeUrl(v.trim());
                if (!raw.startsWith('./assets/')) return '';
                return raw;
            }

            function fromSpeciesObject(speciesObj, wantBack) {
                if (!speciesObj || typeof speciesObj !== 'object') return '';
                if (wantBack && typeof speciesObj.back === 'string') return asLocal(speciesObj.back);
                if (!wantBack && typeof speciesObj.front === 'string') return asLocal(speciesObj.front);
                if (typeof speciesObj.file === 'string') return asLocal(speciesObj.file);
                return '';
            }

            const out = {};
            for (const key of Object.keys(DEFAULT_SPRITE_URLS)) {
                const v = incoming[key];
                if (typeof v === 'string' && v.trim()) {
                    const local = asLocal(v);
                    if (local) out[key] = local;
                    continue;
                }
                const baseKey = key.replace(/Back$/, '').replace(/Battle$/, '');
                const wantBack = /Back$/.test(key);
                const sv = incoming[baseKey];
                const resolved = fromSpeciesObject(sv, wantBack);
                if (resolved) out[key] = resolved;
            }
            return out;
        } catch (e) {
            console.warn('Local sprite config load failed; using bundled local defaults.', e);
            return {};
        }
    }

    async function tryLoadExternalTileset() {
        // Strict local mode: only local user atlas is allowed.
        const png = './assets/tilesets/user.png';
        const json = './assets/tilesets/user.tileset.json';
        try {
            const cfgRes = await fetch(json, {cache: 'no-store'});
            if (!cfgRes.ok) return false;
            const cfg = await cfgRes.json();
            const img = new Image();
            img.crossOrigin = 'anonymous';
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
                img.src = png;
            });
            sprites.tileset = img;
            sprites.tilesetCfg = cfg;
            return true;
        } catch (e) {
            console.warn('Local tileset load failed.', e);
            return false;
        }
    }

    // Disabled in strict-local mode.
    window.setRemoteTileset = function(pngUrl, jsonUrl) { return false; };
    window.setRemoteSprites = function(jsonUrl) { return false; };

    async function loadAssets() {
        const progress = document.getElementById('progressFill');
        const text = document.getElementById('loadingText');

        loadedCount = 0; // Reset loadedCount in case this function is called again

        // Tileset: strict local user assets only.
        const loadedExternal = await tryLoadExternalTileset();
        if (!loadedExternal) {
            // Strict mode: always use user-provided atlas as visual source of truth.
            try {
                const cfgRes = await fetch('./assets/tilesets/user.tileset.json', {cache: 'no-store'});
                const cfg = await cfgRes.json();
                const img = new Image();
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                    img.src = './assets/tilesets/user.png';
                });
                sprites.tileset = img;
                sprites.tilesetCfg = cfg;
            } catch (e) {
                console.error('Failed to load required user tileset assets.', e);
                const loading = document.getElementById('loadingText');
                if (loading) loading.textContent = 'Erro: user tileset ausente/invalido.';
                throw new Error('Required user tileset not available');
            }
        }

        // Optional local sprite overrides from user.sprites.json.
        const spriteOverrides = await tryLoadExternalSpriteConfig();
        SPRITE_URLS = {...DEFAULT_SPRITE_URLS, ...spriteOverrides};

        // Update totalSprites based on active SPRITE_URLS
        const totalSprites = Object.keys(SPRITE_URLS).length;

        // Load story in parallel; do not block asset loading.
        loadStory();

        // Optional prebuilt map backgrounds (for user-imported city/cave sheets).
        if (qs('mapbg', '1') !== '0') {
            try {
                const manifestRes = await fetch('./assets/tilesets/mapbg.manifest.json', {cache: 'no-store'});
                const manifest = await manifestRes.json();
                const fromFile = manifest && typeof manifest === 'object' ? manifest.mapbg : null;
                if (fromFile && typeof fromFile === 'object') {
                    PREBUILT_MAP_BG_CONFIG = fromFile;
                }
            } catch {
                PREBUILT_MAP_BG_CONFIG = {...DEFAULT_PREBUILT_MAP_BG_CONFIG};
            }
            for (const [mapId, conf] of Object.entries(PREBUILT_MAP_BG_CONFIG)) {
                try {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    await new Promise((resolve, reject) => {
                        img.onload = resolve;
                        img.onerror = reject;
                        img.src = conf.url;
                    });
                    prebuiltMapBg[mapId] = {
                        img,
                        ox: conf.ox || 0,
                        oy: conf.oy || 0,
                        px: Number.isFinite(conf.px) ? conf.px : null,
                        py: Number.isFinite(conf.py) ? conf.py : null,
                        ts: Number.isFinite(conf.ts) ? conf.ts : TILE,
                        fixed: !!conf.fixed
                    };
                } catch {
                    // Ignore missing optional files; map falls back to tiled rendering.
                }
            }
        }

        // Optional scene backdrop rules manifest for beat/cutscene visuals.
        try {
            const sceneRes = await fetch('./assets/tilesets/scene_backdrop.manifest.json', {cache: 'no-store'});
            const sceneCfg = await sceneRes.json();
            const rules = sceneCfg && Array.isArray(sceneCfg.rules) ? sceneCfg.rules : null;
            const def = sceneCfg && typeof sceneCfg.default === 'string' ? sceneCfg.default : null;
            if (def) SCENE_BACKDROP_DEFAULT = def;
            if (rules) {
                SCENE_BACKDROP_RULES = rules
                    .filter(r => r && typeof r.match === 'string' && typeof r.url === 'string');
            }
        } catch {
            SCENE_BACKDROP_DEFAULT = DEFAULT_SCENE_BACKDROP;
            SCENE_BACKDROP_RULES = [...DEFAULT_SCENE_BACKDROP_RULES];
        }

        for (const [name, url] of Object.entries(SPRITE_URLS)) {
            text.textContent = `Loading ${name}...`;
            try {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                await new Promise((resolve, reject) => {
                    img.onload = () => {
                        sprites[name] = img;
                        resolve();
                    };
                    img.onerror = () => {
                        console.warn(`Failed to load ${name} from ${url}. Using fallback.`);
                        // Fallback to a simple colored square or skip if no fallback
                        // For tilesets, we might want a default color, for sprites a placeholder
                        if (name.includes('Tiles')) { // Assume tilesets
                            sprites[name] = null; // Indicate failure, will draw colored tile
                        } else { // Assume sprites
                             const fallbackImg = document.createElement('canvas');
                             fallbackImg.width = 16; fallbackImg.height = 16;
                             const fctx = fallbackImg.getContext('2d');
                             fctx.fillStyle = 'red'; fctx.fillRect(0,0,16,16);
                             sprites[name] = fallbackImg;
                        }
                        resolve(); // Continue loading other assets
                    };
                    img.src = url;
                });
            } catch (e) {
                console.error(`Error loading ${name}:`, e);
                sprites[name] = null;
                if (REQUIRED_SPRITE_KEYS.has(name)) {
                    throw new Error(`Required sprite failed to load: ${name}`);
                }
            }
            loadedCount++;
            progress.style.width = (loadedCount / totalSprites * 100) + '%';
        }
        applyVisualSkin();
        
        document.getElementById('loadingScreen').style.display = 'none';
        document.getElementById('titleScreen').style.display = 'flex';
        // Manga-accurate: Poliwhirl is Red's first Pokemon, not Pikachu!
        document.getElementById('titlePokemon').src = SPRITE_URLS.poliwhirl || ''; // Ensure src is valid
    }
    
    // ==================== DRAWING ====================
    function drawSprite(sprite, tx, ty, frame = 0, dir = 'down') {
        const dx = tx * ST;
        const dy = ty * ST;
        if (!sprite) {
            ctx.fillStyle = '#ef4444';
            ctx.fillRect(dx + 6, dy + 4, ST - 12, ST - 8);
            return;
        }

        // FRLG/NPC sheets are usually 16x32 (single frame), while player sheets can be 64x128 (4x4).
        const sw = sprite.naturalWidth || sprite.width || 0;
        const sh = sprite.naturalHeight || sprite.height || 0;
        if (sw <= 0 || sh <= 0) {
            ctx.fillStyle = '#ef4444';
            ctx.fillRect(dx + 6, dy + 4, ST - 12, ST - 8);
            return;
        }

        const dirIdx = {down: 0, left: 1, right: 2, up: 3}[dir] ?? 0;

        // Common FRLG overworld strips (e.g. 144x32 = 9 frames, 3 per direction).
        if (sh >= 32 && sh < 64 && sw >= 48) {
            const cols = Math.floor(sw / 16);
            if (cols >= 3) {
                const step = Math.floor(frame) % 3;
                let base = 0;
                if (cols >= 12) {
                    base = ({down: 0, left: 3, right: 6, up: 9}[dir] ?? 0);
                } else if (cols >= 9) {
                    base = ({down: 0, left: 3, right: 6, up: 0}[dir] ?? 0);
                } else if (cols >= 6) {
                    base = ({down: 0, left: 3, right: 3, up: 0}[dir] ?? 0);
                }
                const frameX = Math.min(cols - 1, base + step) * 16;
                ctx.drawImage(sprite, frameX, 0, 16, 32, dx, dy - (ST / 2), ST, ST * 1.5);
                return;
            }
        }

        const isSheet = (sw >= 64 && sh >= 128);
        if (isSheet) {
            const f = Math.floor(frame) % 4;
            ctx.drawImage(sprite, f * 16, dirIdx * 32, 16, 32, dx, dy - (ST / 2), ST, ST * 1.5);
            return;
        }

        // Static NPC fallback (16x32 or single sprite).
        const srcH = (sh >= 32) ? 32 : sh;
        ctx.drawImage(sprite, 0, 0, Math.min(16, sw), srcH, dx, dy - (ST / 2), ST, ST * 1.5);
    }

    function drawFromAtlas(ax, ay, sx, sy) {
        ctx.drawImage(
            sprites.tileset,
            ax * TILE, ay * TILE,
            TILE, TILE,
            sx * ST, sy * ST,
            ST, ST
        );
    }

    function atlasFor(key, fallbackAx, fallbackAy) {
        const cfg = sprites.tilesetCfg;
        if (!cfg || !cfg.map) return {ax: fallbackAx, ay: fallbackAy};
        const v = cfg.map[key];
        if (!v || typeof v.ax !== 'number' || typeof v.ay !== 'number') return {ax: fallbackAx, ay: fallbackAy};
        return {ax: v.ax, ay: v.ay};
    }

    function noise01(mapId, x, y) {
        // Cheap deterministic hash -> [0,1)
        let h = 2166136261 >>> 0;
        const s = `${mapId}|${x}|${y}`;
        for (let i = 0; i < s.length; i++) {
            h ^= s.charCodeAt(i);
            h = Math.imul(h, 16777619) >>> 0;
        }
        return (h % 1000) / 1000;
    }

    function sameTile(map, x, y, tile) {
        if (!map) return false;
        if (x < 0 || y < 0 || x >= map.w || y >= map.h) return false;
        return map.data[y * map.w + x] === tile;
    }

    function drawEdgeLines(sx, sy, color, a, edgeMask) {
        // edgeMask: {t,b,l,r} booleans
        const x0 = sx * ST;
        const y0 = sy * ST;
        ctx.save();
        ctx.globalAlpha = a;
        ctx.fillStyle = color;
        const w = ST, h = ST;
        const t = 3; // thickness in pixels (scaled-space)
        if (edgeMask.t) ctx.fillRect(x0, y0, w, t);
        if (edgeMask.b) ctx.fillRect(x0, y0 + h - t, w, t);
        if (edgeMask.l) ctx.fillRect(x0, y0, t, h);
        if (edgeMask.r) ctx.fillRect(x0 + w - t, y0, t, h);
        ctx.restore();
    }

    function isBuildingTile(t) {
        return t === T.HOUSE_RED || t === T.HOUSE_BLUE || t === T.LAB;
    }

    function drawTile(tile, sx, sy, mx, my, map) {
        if (!sprites.tileset) {
            ctx.fillStyle = '#000';
            ctx.fillRect(sx * ST, sy * ST, ST, ST);
            return;
        }

        if (tile === T.GRASS) {
            const n = noise01(GS.map, mx, my);
            const a = atlasFor('GRASS', 0, 0);
            const a2 = atlasFor('GRASS_ALT', 1, 2);
            if (n < 0.22) drawFromAtlas(a2.ax, a2.ay, sx, sy);
            else drawFromAtlas(a.ax, a.ay, sx, sy);
            return;
        }
        if (tile === T.PATH) {
            const n = noise01(GS.map, mx, my);
            const a = atlasFor('PATH', 1, 0);
            const a2 = atlasFor('PATH_ALT', 2, 2);
            if (n < 0.18) drawFromAtlas(a2.ax, a2.ay, sx, sy);
            else drawFromAtlas(a.ax, a.ay, sx, sy);
            // Add subtle border where PATH touches GRASS (cheap autotile, FRLG-like).
            const edges = {
                t: !sameTile(map, mx, my - 1, T.PATH) && !sameTile(map, mx, my - 1, T.WARP),
                b: !sameTile(map, mx, my + 1, T.PATH) && !sameTile(map, mx, my + 1, T.WARP),
                l: !sameTile(map, mx - 1, my, T.PATH) && !sameTile(map, mx - 1, my, T.WARP),
                r: !sameTile(map, mx + 1, my, T.PATH) && !sameTile(map, mx + 1, my, T.WARP),
            };
            drawEdgeLines(sx, sy, 'rgba(0,0,0,0.22)', 1.0, edges);
            return;
        }
        if (tile === T.WATER) {
            const a = atlasFor('WATER', 2, 0);
            drawFromAtlas(a.ax, a.ay, sx, sy);
            // Shoreline hint when WATER touches non-water.
            const edges = {
                t: !sameTile(map, mx, my - 1, T.WATER),
                b: !sameTile(map, mx, my + 1, T.WATER),
                l: !sameTile(map, mx - 1, my, T.WATER),
                r: !sameTile(map, mx + 1, my, T.WATER),
            };
            drawEdgeLines(sx, sy, 'rgba(215,191,138,0.55)', 1.0, edges); // sand-ish
            return;
        }
        if (tile === T.TALL_GRASS) { const a = atlasFor('TALL_GRASS', 3, 0); drawFromAtlas(a.ax, a.ay, sx, sy); return; }
        if (tile === T.TREE) { const a = atlasFor('TREE', 4, 0); drawFromAtlas(a.ax, a.ay, sx, sy); return; }
        if (tile === T.FENCE) { const a = atlasFor('FENCE', 5, 0); drawFromAtlas(a.ax, a.ay, sx, sy); return; }
        if (tile === T.SIGN) { const a = atlasFor('SIGN', 6, 0); drawFromAtlas(a.ax, a.ay, sx, sy); return; }
        if (tile === T.FLOWER) { const a = atlasFor('FLOWER', 7, 0); drawFromAtlas(a.ax, a.ay, sx, sy); return; }
        if (tile === T.WARP) { const a = atlasFor('WARP', 0, 2); drawFromAtlas(a.ax, a.ay, sx, sy); return; }
        if (tile === T.NPC) { drawFromAtlas(0, 0, sx, sy); return; } // map marker only
        if (tile === T.FLOOR_IN) { const a = atlasFor('FLOOR_IN', 6, 1); drawFromAtlas(a.ax, a.ay, sx, sy); return; }
        if (tile === T.WALL_IN) { const a = atlasFor('WALL_IN', 7, 1); drawFromAtlas(a.ax, a.ay, sx, sy); return; }
        if (tile === T.TABLE) { const a = atlasFor('TABLE', 0, 3); drawFromAtlas(a.ax, a.ay, sx, sy); return; }
        if (tile === T.SHELF) { const a = atlasFor('SHELF', 1, 3); drawFromAtlas(a.ax, a.ay, sx, sy); return; }

        if (isBuildingTile(tile)) {
            const same = (x, y) => {
                if (x < 0 || y < 0 || x >= map.w || y >= map.h) return false;
                return map.data[y * map.w + x] === tile;
            };
            const top = !same(mx, my - 1);
            const bottom = !same(mx, my + 1);
            const leftEdge = !same(mx - 1, my);
            const rightEdge = !same(mx + 1, my);

            const roofKey = (tile === T.HOUSE_RED) ? 'ROOF_RED' : (tile === T.HOUSE_BLUE) ? 'ROOF_BLUE' : 'ROOF_LAB';
            const roofAxAy = atlasFor(roofKey, (tile === T.HOUSE_RED) ? 0 : (tile === T.HOUSE_BLUE) ? 1 : 2, 1);
            if (top) {
                drawFromAtlas(roofAxAy.ax, roofAxAy.ay, sx, sy);
                // subtle roof edge shade
                ctx.fillStyle = 'rgba(0,0,0,0.10)';
                if (leftEdge) ctx.fillRect(sx * ST, sy * ST, 3, ST);
                if (rightEdge) ctx.fillRect(sx * ST + ST - 3, sy * ST, 3, ST);
                return;
            }

            // base wall
            const wallAxAy = atlasFor('WALL', 3, 1);
            drawFromAtlas(wallAxAy.ax, wallAxAy.ay, sx, sy);

            // door on bottom row, center-ish
            if (bottom) {
                const doorCandidate = same(mx - 1, my) && same(mx + 1, my);
                if (doorCandidate) {
                    const doorAxAy = atlasFor('DOOR', 4, 1);
                    drawFromAtlas(doorAxAy.ax, doorAxAy.ay, sx, sy);
                    return;
                }
            }

            // window on mid walls
            if (!leftEdge && !rightEdge && !bottom) {
                if (((mx + my) % 4) === 0) {
                    const winAxAy = atlasFor('WINDOW', 5, 1);
                    drawFromAtlas(winAxAy.ax, winAxAy.ay, sx, sy);
                }
            }
            return;
        }

        // fallback
        ctx.fillStyle = '#000';
        ctx.fillRect(sx * ST, sy * ST, ST, ST);
    }

    function renderFrame() {
        // Defensive runtime self-heal for stale UI/cutscene flags after iPad tap races.
        clearOrphanRuntimeLocks();

        const map = MAPS[GS.map];
        if (!map) {
            SceneManager.clearRenderLayer();
            return;
        }
        if (SceneManager.currentScene !== GS.map) {
            SceneManager.loadScene(GS.map);
        }
        
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        const camX = Math.floor(GS.px - VW / 2);
        const camY = Math.floor(GS.py - VH / 2);
        const forceTileRender = ALWAYS_TILE_RENDER_MAPS.has(GS.map);
        const mapBgEntry = (PREBUILT_SKIP_MAPS.has(GS.map) || forceTileRender) ? null : prebuiltMapBg[GS.map];
        const overlayMode = cutsceneLock && hasSceneBackdrop();
        const hasMapBg = !!mapBgEntry && !overlayMode;
        if (!hasMapBg && STYLE_LOCK_CORE_MAPS.has(GS.map) && qs('stylelock', '1') !== '0') {
            dbg(`stylelock: missing mapbg for ${GS.map}; using atlas fallback`);
        }
        if (hasMapBg) {
            // Stable crop from prebuilt maps; avoids stretch artifacts near bounds.
            const mapBg = mapBgEntry.img;
            const srcTile = mapBgEntry.ts || TILE;
            const srcW = VW * srcTile;
            const srcH = VH * srcTile;
            const originX = Number.isFinite(mapBgEntry.px)
                ? Math.floor(mapBgEntry.px)
                : Math.floor((mapBgEntry.ox || 0) * srcTile);
            const originY = Number.isFinite(mapBgEntry.py)
                ? Math.floor(mapBgEntry.py)
                : Math.floor((mapBgEntry.oy || 0) * srcTile);
            const maxX = Math.max(0, mapBg.width - srcW);
            const maxY = Math.max(0, mapBg.height - srcH);
            const srcX = mapBgEntry.fixed
                ? Math.max(0, Math.min(maxX, originX))
                : Math.max(0, Math.min(maxX, originX + Math.floor(camX * srcTile)));
            const srcY = mapBgEntry.fixed
                ? Math.max(0, Math.min(maxY, originY))
                : Math.max(0, Math.min(maxY, originY + Math.floor(camY * srcTile)));
            if (srcW > 0 && srcH > 0) {
                ctx.drawImage(mapBg, srcX, srcY, srcW, srcH, 0, 0, canvas.width, canvas.height);
            }
        }
        
        // Draw tiles
        if (!hasMapBg) {
            for (let sy = 0; sy < VH + 1; sy++) {
                for (let sx = 0; sx < VW + 1; sx++) {
                    const mx = camX + sx;
                    const my = camY + sy;
                    if (mx >= 0 && mx < map.w && my >= 0 && my < map.h) {
                        const tile = map.data[my * map.w + mx];
                        drawTile(tile, sx, sy, mx, my, map);
                    }
                }
            }
        }
        
        // Draw NPCs
        if (map.npcs) {
            for (const npc of map.npcs) {
                const sx = npc.x - camX;
                const sy = npc.y - camY;
                if (sx >= -1 && sx <= VW && sy >= -1 && sy <= VH) {
                    drawSprite(sprites[npc.sprite], sx, sy, 0, 'down');
                }
            }
        }
        
        // Draw Pikachu follower
        if (GS.hasPikachu) {
            const psx = GS.px - camX - 1;
            const psy = GS.py - camY;
            if (sprites.pikachuOW && sprites.pikachuOW.complete) {
                ctx.drawImage(sprites.pikachuOW, 0, 0, 32, 32, psx * ST, psy * ST, ST, ST);
            } else {
                ctx.fillStyle = '#f8d030';
                ctx.fillRect(psx * ST + 4, psy * ST + 4, ST - 8, ST - 8);
            }
        }
        
        // Draw player
        const psx = GS.px - camX;
        const psy = GS.py - camY;
        drawSprite(sprites.red, psx, psy, animFrame, GS.dir);
        
        // Only animate when moving (not standing still)
        if (moveDir || storyMoveTimer) {
            animFrame = (animFrame + 0.15) % 4;
        } else {
            animFrame = 0; // Standing still = first frame
        }
    }

    function stopRenderLoop() {
        renderLoopActive = false;
        renderLoopToken++;
        if (renderRafId) {
            cancelAnimationFrame(renderRafId);
            renderRafId = 0;
        }
    }

    function startRenderLoop() {
        if (renderLoopActive) return;
        renderLoopActive = true;
        const token = ++renderLoopToken;
        const tick = () => {
            if (!renderLoopActive || token !== renderLoopToken) return;
            renderFrame();
            renderRafId = requestAnimationFrame(tick);
        };
        tick();
    }
    
    // ==================== MOVEMENT ====================
    function isWalkableOnMap(map, x, y, ignoreNpc = false) {
        if (!map || x < 0 || x >= map.w || y < 0 || y >= map.h) return false;
        if (currentCollisionGrid && currentCollisionMapId === GS.map && currentCollisionW === map.w && currentCollisionH === map.h) {
            if (currentCollisionGrid[y * map.w + x]) return false;
        } else {
            const tile = map.data[y * map.w + x];
            if (SOLID.includes(tile)) return false;
        }
        if (!ignoreNpc && map.npcs) for (const n of map.npcs) if (n.x === x && n.y === y) return false;
        return true;
    }

    function ensureWalkablePlayerPosition() {
        const map = MAPS[GS.map];
        if (!map) return;
        if (isWalkableOnMap(map, GS.px, GS.py, true)) return;

        // Find nearest walkable tile around current position.
        for (let r = 1; r <= 16; r++) {
            for (let dy = -r; dy <= r; dy++) {
                for (let dx = -r; dx <= r; dx++) {
                    if (Math.abs(dx) + Math.abs(dy) > r) continue;
                    const tx = GS.px + dx;
                    const ty = GS.py + dy;
                    if (isWalkableOnMap(map, tx, ty, true)) {
                        GS.px = tx;
                        GS.py = ty;
                        return;
                    }
                }
            }
        }

        // Fallback full scan (should rarely happen).
        for (let y = 0; y < map.h; y++) {
            for (let x = 0; x < map.w; x++) {
                if (isWalkableOnMap(map, x, y, true)) {
                    GS.px = x;
                    GS.py = y;
                    return;
                }
            }
        }
    }

    function canMove(x, y) {
        const map = MAPS[GS.map];
        return isWalkableOnMap(map, x, y, false);
    }
    
    function move(dir) {
        // Self-heal stuck flags before movement gate checks.
        clearOrphanRuntimeLocks();
        if (dialog || inBattle || cutsceneLock) {
            stopMove();
            return;
        }
        let nx = GS.px, ny = GS.py;
        if (dir === 'up') ny--;
        else if (dir === 'down') ny++;
        else if (dir === 'left') nx--;
        else if (dir === 'right') nx++;
        
        if (canMove(nx, ny)) {
            GS.dir = dir;
            GS.px = nx; GS.py = ny;
            checkWarp();
            checkEncounter();
            scheduleSave('move');
        }
    }
    
    let runPressed = false;
    function setRunPressed(v) { runPressed = !!v; }
    function moveStepMs() { return runPressed ? 85 : 145; }
    function startMove(dir) {
        // Runtime self-heal for rare iPad/tap race conditions where dialog/cutscene flags stick.
        clearOrphanRuntimeLocks();
        if (dialog || inBattle || cutsceneLock) {
            stopMove();
            return;
        }
        stopMove();
        move(dir);
        if (dialog || inBattle || cutsceneLock) return;
        moveDir = dir;
        moveInt = setTimeout(function tick() {
            if (!moveDir) return;
            move(moveDir);
            moveInt = setTimeout(tick, moveStepMs());
        }, 120);
    }
    function stopMove() {
        if (moveInt) {
            clearTimeout(moveInt);
            moveInt = null;
        }
        moveDir = null;
    }
    
    // ==================== WARPS ====================
    function checkWarp() {
        const map = MAPS[GS.map];
        if (!map || !map.warps) return;
        for (const w of map.warps) {
            if (GS.px === w.x && GS.py === w.y) {
                GS.map = w.to;
                GS.px = w.tx;
                GS.py = w.ty;
                ensureWalkablePlayerPosition();
                onMapEnter(GS.map, {preserveFlow: false});
                scheduleSave('warp');
                break;
            }
        }
    }

    function tryAutoStoryBeat() {
        if (!GS.story) return false;
        if (activeBeatId || dialog || inBattle) return false;
        const mapId = GS.map;

        if (mapId === 'oak_lab' && GS.story.sawMew && !GS.story.gotSaur) {
            return playBeat('ch1_oak_mew_explain');
        }
        if (mapId === 'viridian' && !GS.story.visitedViridian) {
            GS.story.visitedViridian = true;
            return playBeat('ch1_viridian_arrival');
        }
        if (mapId === 'viridian_forest' && GS.story.gotSaur && !GS.story.forestBeat1) {
            GS.story.forestBeat1 = true;
            return playBeat('ch1_viridian_forest_first');
        }
        if (mapId === 'pewter' && !GS.story.visitedPewter) {
            GS.story.visitedPewter = true;
            return playBeat('ch1_pewter_arrival');
        }
        if (mapId === 'pewter' && GS.story.brockBattleDone && !GS.story.block_02_done) {
            return playBeat('ch2_depart_pewter');
        }
        if (mapId === 'route2' && GS.story.block_02_done && !GS.story.block_03_done) {
            return playBeat('ch2_mtmoon_entry');
        }
        if (mapId === 'mt_moon' && GS.story.block_03_done && !GS.story.block_04_done) {
            return playBeat('ch2_green_first_contact');
        }
        if (mapId === 'mt_moon' && GS.story.block_04_done && !GS.story.block_05_done) {
            return playBeat('ch2_rocket_grunt_cave');
        }
        if (mapId === 'mt_moon' && GS.story.block_05_done && !GS.story.block_06_done) {
            return playBeat('ch2_fossil_rumor');
        }
        if (mapId === 'cerulean' && GS.story.block_06_done && !GS.story.block_07_done) {
            return playBeat('ch3_cerulean_arrival');
        }
        if (mapId === 'cerulean' && GS.story.block_07_done && !GS.story.block_08_done) {
            return playBeat('ch3_misty_clash');
        }
        if (mapId === 'cerulean' && GS.story.block_08_done && !GS.story.block_09_done) {
            return playBeat('ch3_bill_event');
        }
        if (mapId === 'vermilion' && GS.story.block_09_done && !GS.story.block_10_done) {
            return playBeat('ch4_vermilion_setup');
        }
        if (mapId === 'vermilion' && GS.story.block_10_done && !GS.story.block_11_done) {
            return playBeat('ch4_ssanne_rocket');
        }
        if (mapId === 'vermilion' && GS.story.block_11_done && !GS.story.block_12_done) {
            return playBeat('ch5_surge_pressure');
        }
        if (mapId === 'lavender' && GS.story.block_12_done && !GS.story.block_13_done) {
            return playBeat('ch6_lavender_shadow');
        }
        if (mapId === 'silph_lobby' && GS.story.block_13_done && !GS.story.block_14_done) {
            return playBeat('ch7_silph_infiltration');
        }
        if (mapId === 'saffron' && GS.story.block_14_done && !GS.story.block_15_done) {
            return playBeat('ch8_saffron_psychic');
        }
        if (mapId === 'silph_lobby' && GS.story.block_15_done && !GS.story.block_16_done) {
            return playBeat('ch9_final_island_setup');
        }
        if (mapId === 'silph_lobby' && GS.story.block_16_done && !GS.story.block_17_done) {
            return playBeat('ch10_mewtwo_confront');
        }
        if (mapId === 'fuchsia' && GS.story.block_17_done && !GS.story.block_18_done) {
            return playBeat('ch11_aftershock_recovery');
        }
        if (mapId === 'cinnabar' && GS.story.block_18_done && !GS.story.block_19_done) {
            return playBeat('ch12_cinnabar_research');
        }
        if (mapId === 'viridian_gym' && GS.story.block_19_done && !GS.story.block_20_done) {
            return playBeat('ch13_viridian_giovanni');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_20_done && !GS.story.block_21_done) {
            return playBeat('ch14_indigo_opening');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_21_done && !GS.story.block_22_done) {
            return playBeat('ch15_elite_lance');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_22_done && !GS.story.block_23_done) {
            return playBeat('ch16_blue_champion');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_23_done && !GS.story.block_24_done) {
            return playBeat('ch17_season1_epilogue');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_24_done && !GS.story.block_25_done) {
            return playBeat('ch18_oak_debrief');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_25_done && !GS.story.block_26_done) {
            return playBeat('ch19_green_reveal');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_26_done && !GS.story.block_27_done) {
            return playBeat('ch20_lance_warning');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_27_done && !GS.story.block_28_done) {
            return playBeat('ch21_rocket_remnant');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_28_done && !GS.story.block_29_done) {
            return playBeat('ch22_red_blue_duel');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_29_done && !GS.story.block_30_done) {
            return playBeat('ch23_team_unity');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_30_done && !GS.story.block_31_done) {
            return playBeat('ch24_mew_trace');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_31_done && !GS.story.block_32_done) {
            return playBeat('ch25_training_push');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_32_done && !GS.story.block_33_done) {
            return playBeat('ch26_kanto_peace');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_33_done && !GS.story.block_34_done) {
            return playBeat('ch27_season1_closure');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_34_done && !GS.story.block_35_done) {
            return playBeat('ch28_vs_nidorino');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_35_done && !GS.story.block_36_done) {
            return playBeat('ch29_vs_fearow');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_36_done && !GS.story.block_37_done) {
            return playBeat('ch30_vs_snorlax');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_37_done && !GS.story.block_38_done) {
            return playBeat('ch31_vs_exeggutor');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_38_done && !GS.story.block_39_done) {
            return playBeat('ch32_vs_gyarados');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_39_done && !GS.story.block_40_done) {
            return playBeat('ch33_vs_porygon');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_40_done && !GS.story.block_41_done) {
            return playBeat('ch34_vs_hitmonlee');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_41_done && !GS.story.block_42_done) {
            return playBeat('ch35_vs_hypno');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_42_done && !GS.story.block_43_done) {
            return playBeat('ch36_vs_gengar');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_43_done && !GS.story.block_44_done) {
            return playBeat('ch37_vs_alakazam');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_44_done && !GS.story.block_45_done) {
            return playBeat('ch38_vs_machamp');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_45_done && !GS.story.block_46_done) {
            return playBeat('ch39_vs_dugtrio');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_46_done && !GS.story.block_47_done) {
            return playBeat('ch40_vs_rhydon');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_47_done && !GS.story.block_48_done) {
            return playBeat('ch41_vs_dragonair');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_48_done && !GS.story.block_49_done) {
            return playBeat('ch42_rgb_full_closure');
        }
        if (mapId === 'indigo_plateau' && GS.story.block_49_done && !GS.story.block_50_done) {
            return playBeat('s1_outline_next');
        }
        return false;
    }

    function onMapEnter(mapId, opts = {}) {
        const preserveFlow = !!opts.preserveFlow;
        stopMove();
        const changed = SceneManager.currentScene !== mapId;
        if (changed) {
            SceneManager.unloadScene({preserveFlow});
            SceneManager.loadScene(mapId);
        } else {
            SceneManager.clearRenderLayer();
            loadCollisionGrid(mapId);
        }
        // Lightweight, non-breaking story hooks. Real season script will live in beats/flags.
        if (!GS.story) GS.story = {};
        ensureWalkablePlayerPosition();
        clearOrphanRuntimeLocks();
        setSceneBackdrop('');
        showMapBanner(mapId);
        if (mapId === 'pewter_gym' && GS.story.autoBrock && GS.story.caughtPika && !GS.story.brockBattleDone) {
            GS.story.autoBrock = false;
            scheduleSave('story-auto-brock');
            setTimeout(() => { playBeat('ch1_brock_intro'); }, 240);
            return;
        }
        if (mapId === 'pewter_gym' && GS.story.caughtPika && !GS.story.brockBattleDone) {
            setTimeout(() => {
                showDialog('', [
                    '[ PEWTER GYM ]',
                    'BROCK observa em silencio do outro lado da arena.',
                    'A luta comeca quando voce falar com ele.'
                ]);
            }, 320);
        }
        setTimeout(async () => {
            await ensureStoryLoaded();
            tryAutoStoryBeat();
        }, 260);
    }
    
    // ==================== ENCOUNTERS ====================
    const GAME_MODE = {
        // When true: encounters/battles/captures/evolutions are driven by story beats (manga).
        // Random encounters are disabled to avoid grind and keep narrative control.
        storyLock: true,
        // When true and storyLock is false, allow tall grass RNG encounters.
        randomEncounters: true,
    };

    function checkEncounter() {
        const map = MAPS[GS.map];
        // Need Poliwhirl (or any team Pokemon) to battle
        if (!map || !map.enc || !GS.story.gotSaur || GS.team.length === 0) return;
        if (GAME_MODE.storyLock) return; // manga-driven only
        if (!GAME_MODE.randomEncounters) return;
        const tile = map.data[GS.py * map.w + GS.px];
        if (tile !== T.TALL_GRASS) return;
        if (Math.random() * 100 < map.enc.rate) {
            const roll = Math.random() * 100;
            let cum = 0;
            for (const p of map.enc.pokemon) {
                cum += p.rate;
                if (roll < cum) {
                    const lv = p.lv[0] + Math.floor(Math.random() * (p.lv[1] - p.lv[0] + 1));
                    startBattle({name: p.name, spr: p.spr, lv, hp: 10 + lv * 2, maxHp: 10 + lv * 2});
                    return;
                }
            }
        }
    }
    
    // ==================== BATTLE ====================
    // Get current active Pokemon (first healthy one in team)
    function getActivePokemon() {
        if (GS.team.length === 0) return GS.poli; // Fallback
        return GS.team[0]; // For now, first Pokemon
    }

    function setBattleLog(text) {
        document.getElementById('battleLog').textContent = text;
    }

    function showBattleOk(label = 'OK') {
        const btn = document.getElementById('battleOkBtn');
        btn.textContent = label;
        document.getElementById('battleOk').style.display = 'block';
    }

    function hideBattleOk() {
        document.getElementById('battleOk').style.display = 'none';
    }

    // Manga-first UX: battles are scripted, player only confirms (A/OK) to proceed.
    function battleWaitOk(label, fn) {
        battle.pending = fn;
        showBattleOk(label);
    }

    function battleOk() {
        if (!inBattle || !battle) return;
        if (!battle.pending) return;
        const fn = battle.pending;
        battle.pending = null;
        hideBattleOk();
        fn();
    }

    function battleScriptedStep() {
        if (!battle || !battle.scripted) return;
        const steps = battle.scriptSteps || [];
        if (battle.scriptIndex >= steps.length) {
            endBattle(true);
            return;
        }
        const step = steps[battle.scriptIndex++];

        if (step.type === 'log') {
            setBattleLog(step.text || '...');
            battleWaitOk('OK', () => battleScriptedStep());
            return;
        }

        if (step.type === 'playerMove') {
            const active = getActivePokemon();
            const moveName = step.move || 'Tackle';
            // Use proportional damage calculation if no step.damage specified
            const attacker = { species: active.species, lv: active.lv || 10 };
            const defender = { species: battle.enemy.name, lv: battle.enemy.lv || 10 };
            const dmg = step.damage !== undefined ? Math.max(0, step.damage) : calcBattleDamage(attacker, defender, moveName);
            setBattleLog(`${active.name || active.species} vai usar ${moveName}.`);
            battleWaitOk('OK', () => {
                battle.enemy.hp = Math.max(0, battle.enemy.hp - dmg);
                const pct = battle.enemy.hp / battle.enemy.maxHp * 100;
                const bar = document.getElementById('enemyHp');
                bar.style.width = pct + '%';
                bar.className = 'hp-fill' + (pct < 20 ? ' critical' : pct < 50 ? ' low' : '');
                const effMsg = dmg > 15 ? ' Super efetivo!' : dmg < 5 ? ' Não foi muito efetivo...' : '';
                setBattleLog(`${active.name || active.species} usou ${moveName}! ${dmg} de dano!${effMsg}`.trim());
                if (battle.enemy.hp <= 0) { setTimeout(() => endBattle(true), 700); return; }
                setTimeout(() => battleScriptedStep(), 500);
            });
            return;
        }

        if (step.type === 'enemyMove') {
            const active = getActivePokemon();
            const moveName = step.move || 'Tackle';
            // Use proportional damage calculation if no step.damage specified
            const attacker = { species: battle.enemy.name, lv: battle.enemy.lv || 10 };
            const defender = { species: active.species, lv: active.lv || 10 };
            const dmg = step.damage !== undefined ? Math.max(0, step.damage) : calcBattleDamage(attacker, defender, moveName);
            setBattleLog(`${battle.enemy.name} vai atacar.`);
            battleWaitOk('OK', () => {
                active.hp = Math.max(0, active.hp - dmg);
                updatePlayerHp();
                const effMsg = dmg > 15 ? ' Super efetivo!' : dmg < 5 ? ' Não foi muito efetivo...' : '';
                setBattleLog(`${battle.enemy.name} usou ${moveName}! ${dmg} de dano!${effMsg}`.trim());
                if (active.hp <= 0) { setTimeout(() => endBattle(false), 700); return; }
                setTimeout(() => battleScriptedStep(), 500);
            });
            return;
        }

        if (step.type === 'usePotion') {
            const active = getActivePokemon();
            const heal = Math.max(0, step.heal ?? 20);
            setBattleLog(`Usar POTION em ${active.name || active.species}?`);
            battleWaitOk('OK', () => {
                if (GS.items.potion > 0) GS.items.potion--;
                active.hp = Math.min(active.maxHp, active.hp + heal);
                updatePlayerHp();
                setBattleLog(`POTION! +${heal} HP.`);
                setTimeout(() => battleScriptedStep(), 500);
            });
            return;
        }

        if (step.type === 'capture') {
            // Capture is story-driven. We only show it and advance.
            const who = step.who || battle.enemy.name;
            setBattleLog(`Tentar capturar ${who}.`);
            battleWaitOk('OK', () => {
                setBattleLog(`${who} foi capturado!`);
                // Hook: caller can set flags/team in onCapture
                if (battle.onCapture) battle.onCapture(who);
                setTimeout(() => battleScriptedStep(), 500);
            });
            return;
        }

        if (step.type === 'end') {
            endBattle(!!step.won);
            return;
        }

        // Unknown step: skip safely
        battleScriptedStep();
    }
    
    function startBattle(enemy, opts = {}) {
        inBattle = true;
        const active = getActivePokemon();
        battle = {
            enemy,
            turn: 'player',
            active,
            scripted: !!opts.scripted || (GAME_MODE.storyLock && opts.scripted !== false),
            scriptSteps: Array.isArray(opts.scriptSteps) ? opts.scriptSteps : null,
            scriptIndex: 0,
            pending: null,
            onEnd: typeof opts.onEnd === 'function' ? opts.onEnd : null,
            onCapture: typeof opts.onCapture === 'function' ? opts.onCapture : null,
        };
        
        document.getElementById('enemyName').textContent = enemy.name;
        document.getElementById('enemyLevel').textContent = 'Lv. ' + enemy.lv;
        document.getElementById('enemySprite').src = SPRITE_URLS[enemy.spr] || '';
        document.getElementById('enemyHp').style.width = '100%';
        
        // Use active team Pokemon (Poliwhirl to start)
        document.getElementById('playerName').textContent = active.name || active.species;
        document.getElementById('playerLevel').textContent = 'Lv. ' + active.lv;
        // Try back sprite, fallback to front
        const backSprite = SPRITE_URLS[active.species?.toLowerCase() + 'Back'] || 
                          SPRITE_URLS.poliwhirlBack;
        document.getElementById('playerSprite').src = backSprite;
        updatePlayerHp();
        
        setBattleLog(`Um ${enemy.name} apareceu!`);
        document.getElementById('battleScreen').style.display = 'flex';
        document.getElementById('movesMenu').style.display = 'none';
        hideBattleOk();
        applyBattleVisuals(enemy, opts);

        if (battle.scripted) {
            // In manga-first mode, hide menus and run the script.
            document.getElementById('battleMenu').style.display = 'none';
            // Default scripted flow if caller didn't pass steps (safe minimal fight).
            if (!battle.scriptSteps) {
                battle.scriptSteps = [
                    {type: 'log', text: `Um ${enemy.name} selvagem apareceu!`},
                    {type: 'playerMove', move: 'Water Gun', damage: 8},
                    {type: 'enemyMove', move: 'Tackle', damage: 4},
                    {type: 'playerMove', move: 'Water Gun', damage: 10},
                    {type: 'end', won: true},
                ];
            }
            battle.scriptIndex = 0;
            battleScriptedStep();
        } else {
            document.getElementById('battleMenu').style.display = 'grid';
            buildMoves();
        }
    }
    
    function updatePlayerHp() {
        const active = getActivePokemon();
        const pct = active.hp / active.maxHp * 100;
        const bar = document.getElementById('playerHp');
        bar.style.width = pct + '%';
        bar.className = 'hp-fill' + (pct < 20 ? ' critical' : pct < 50 ? ' low' : '');
        document.getElementById('playerCurrentHp').textContent = active.hp;
        document.getElementById('playerMaxHp').textContent = active.maxHp;
    }
    
    // Poliwhirl's moves (manga-accurate)
    const POLI_MOVES = [
        {name: 'Water Gun', type: 'water', pow: 40},
        {name: 'Double Slap', type: 'normal', pow: 35},
        {name: 'Hypnosis', type: 'psychic', pow: 0},
        {name: 'Bubble Beam', type: 'water', pow: 65}
    ];
    
    const MOVES = POLI_MOVES; // Default moves (will be dynamic later)
    
    function buildMoves() {
        const grid = document.getElementById('movesGrid');
        grid.innerHTML = '';
        for (const m of MOVES) {
            const btn = document.createElement('button');
            btn.className = `move-btn type-${m.type}`;
            btn.innerHTML = `<div class="move-name">${m.name}</div>`;
            btn.onclick = () => useMove(m);
            grid.appendChild(btn);
        }
    }
    
    function showMoves() {
        document.getElementById('battleMenu').style.display = 'none';
        document.getElementById('movesMenu').style.display = 'block';
    }
    
    function hideMoves() {
        document.getElementById('movesMenu').style.display = 'none';
        document.getElementById('battleMenu').style.display = 'grid';
    }
    
    function useMove(m) {
        if (battle.turn !== 'player') return;
        battle.turn = 'enemy';
        
        const active = getActivePokemon();
        let dmg = 0;
        if (m.pow > 0) {
            dmg = Math.floor((m.pow * active.lv / 50) + 2 + Math.random() * 5);
            // Type effectiveness
            if (m.type === 'water' && ['GEODUDE', 'ONIX', 'RHYHORN'].includes(battle.enemy.name)) dmg *= 2;
            if (m.type === 'electric' && battle.enemy.name === 'PIDGEY') dmg *= 2;
        }
        
        battle.enemy.hp = Math.max(0, battle.enemy.hp - dmg);
        const pct = battle.enemy.hp / battle.enemy.maxHp * 100;
        const bar = document.getElementById('enemyHp');
        bar.style.width = pct + '%';
        bar.className = 'hp-fill' + (pct < 20 ? ' critical' : pct < 50 ? ' low' : '');
        
        const pokeName = active.name || active.species;
        document.getElementById('battleLog').textContent = `${pokeName} usou ${m.name}!${dmg ? ` ${dmg} de dano!` : ''}`;
        
        if (battle.enemy.hp <= 0) { setTimeout(() => endBattle(true), 1000); return; }
        setTimeout(enemyTurn, 1500);
    }
    
    function enemyTurn() {
        const active = getActivePokemon();
        const dmg = Math.floor((30 * battle.enemy.lv / 50) + 2 + Math.random() * 3);
        active.hp = Math.max(0, active.hp - dmg);
        updatePlayerHp();
        document.getElementById('battleLog').textContent = `${battle.enemy.name} atacou! ${dmg} de dano!`;
        if (active.hp <= 0) { setTimeout(() => endBattle(false), 1000); return; }
        battle.turn = 'player';
        hideMoves();
    }
    
    function endBattle(won) {
        const active = getActivePokemon();
        const pokeName = active.name || active.species;
        
        if (won) {
            // Calculate XP based on enemy level and type
            const baseExp = battle.enemy.lv * 12;
            const bonusExp = battle.enemy.name === 'MEWTWO' ? 500 : 
                            battle.enemy.lv >= 50 ? 100 : 
                            battle.enemy.lv >= 30 ? 50 : 0;
            const totalExp = baseExp + bonusExp;
            
            active.exp = (active.exp || 0) + totalExp;
            const expNeeded = active.lv * 60 + 40; // Progressive XP curve
            
            if (active.exp >= expNeeded) {
                // LEVEL UP!
                active.lv++;
                active.exp = active.exp - expNeeded;
                
                // Stat boosts based on Pokemon
                const hpBoost = active.species === 'SNORLAX' ? 8 : 
                               active.species === 'PIKACHU' ? 2 : 3;
                active.maxHp += hpBoost;
                active.hp = active.maxHp; // Full heal on level up
                
                // Visual feedback
                const canvas = document.getElementById('gameCanvas');
                canvas.classList.add('evolving');
                setTimeout(() => canvas.classList.remove('evolving'), 800);
                
                document.getElementById('battleLog').textContent = `🎉 ${pokeName} subiu para Lv.${active.lv}! HP+${hpBoost}`;
            } else {
                document.getElementById('battleLog').textContent = `+${totalExp} EXP! (${active.exp}/${expNeeded})`;
            }
        } else {
            document.getElementById('battleLog').textContent = `${pokeName} foi derrotado...`;
            active.hp = Math.max(1, Math.floor(active.maxHp / 2)); // Don't fully faint
        }
        setTimeout(() => {
            document.getElementById('battleScreen').style.display = 'none';
            inBattle = false;
            const onEnd = battle && battle.onEnd ? battle.onEnd : null;
            const wonFinal = won;
            battle = null;
            saveGame();
            if (onEnd) onEnd(wonFinal);
        }, 2000);
    }
    
    function tryRun() {
        if (GAME_MODE.storyLock) {
            document.getElementById('battleLog').textContent = 'Nao da para fugir!';
            setTimeout(enemyTurn, 1000);
            return;
        }
        if (Math.random() < 0.7) {
            document.getElementById('battleLog').textContent = 'Voce fugiu em seguranca!';
            setTimeout(() => {
                document.getElementById('battleScreen').style.display = 'none';
                inBattle = false;
                battle = null;
            }, 1000);
        } else {
            document.getElementById('battleLog').textContent = 'Nao da para fugir!';
            setTimeout(enemyTurn, 1000);
        }
    }
    
    function useBag() {
        const active = getActivePokemon();
        if (GS.items.potion > 0 && active.hp < active.maxHp) {
            GS.items.potion--;
            active.hp = Math.min(active.maxHp, active.hp + 20);
            document.getElementById('battleLog').textContent = 'Usou POTION! +20 HP!';
            updatePlayerHp();
            setTimeout(enemyTurn, 1500);
        } else {
            document.getElementById('battleLog').textContent = GS.items.potion > 0 ? 'HP cheio!' : 'Sem potions!';
        }
    }
    
    function showPokemon() {
        const active = getActivePokemon();
        const pokeName = active.name || active.species;
        document.getElementById('battleLog').textContent = `${pokeName} Lv.${active.lv} HP:${active.hp}/${active.maxHp}`;
    }
    
    // ==================== DIALOG ====================
    function showDialog(speaker, texts, cb) {
        actionProgressAt = Date.now();
        stopMove();
        const lines = Array.isArray(texts) ? texts : [texts];
        dialogQ = lines.map(v => String(v ?? '...'));
        dialog = {speaker, cb};
        nextDialog();
    }
    
    function nextDialog() {
        actionProgressAt = Date.now();
        if (!dialog) {
            clearDialogAutoAdvance();
            const box = document.getElementById('dialogBox');
            const portrait = box ? box.querySelector('#dialogPortrait') : null;
            if (portrait) {
                portrait.style.display = 'none';
                portrait.removeAttribute('src');
            }
            document.getElementById('dialogBox').style.display = 'none';
            document.getElementById('tapOverlay').style.display = 'none';
            dialogQ = [];
            return;
        }
        if (dialogQ.length === 0) {
            clearDialogAutoAdvance();
            const box = document.getElementById('dialogBox');
            const portrait = box ? box.querySelector('#dialogPortrait') : null;
            if (portrait) {
                portrait.style.display = 'none';
                portrait.removeAttribute('src');
            }
            document.getElementById('dialogBox').style.display = 'none';
            document.getElementById('tapOverlay').style.display = 'none';
            // Important: clear dialog state BEFORE invoking cb.
            // Story runner chains many dialog actions; the callback commonly opens the next dialog.
            // If we null-out after cb, we can wipe the newly opened dialog and "freeze" on iPad.
            const cb = dialog && dialog.cb ? dialog.cb : null;
            dialog = null;
            dialogQ = [];
            if (cb) {
                try {
                    cb();
                } catch (err) {
                    dbg(`dialog callback error: ${err && err.message ? err.message : String(err)}`);
                    activeBeatId = null;
                    cutsceneLock = false;
                }
            }
            return;
        }
        const box = document.getElementById('dialogBox');
        const speakerEl = box.querySelector('.speaker');
        const textEl = box.querySelector('.text');
        const portraitEl = box.querySelector('#dialogPortrait');
        if (dialog.speaker) {
            speakerEl.style.display = 'block';
            speakerEl.textContent = dialog.speaker;
        } else {
            speakerEl.style.display = 'none';
            speakerEl.textContent = '';
        }
        const line = dialogQ.shift();
        textEl.textContent = line;
        const portraitKey = dialogPortraitKeyFor(dialog.speaker, line);
        if (portraitEl && portraitKey && SPRITE_URLS[portraitKey]) {
            portraitEl.src = SPRITE_URLS[portraitKey];
            portraitEl.style.display = 'block';
        } else if (portraitEl) {
            portraitEl.style.display = 'none';
            portraitEl.removeAttribute('src');
        }
        box.style.display = 'block';
        document.getElementById('tapOverlay').style.display = 'block';
        scheduleDialogAutoAdvance();
    }
    
    // ==================== INPUT ====================
    // Get dynamic dialog for NPCs based on story state
    function getDynamicDialog(npc) {
        // Blue's dialog changes based on story
        if (npc.name === 'Blue') {
            if (!GS.story.sawMew) {
                return [
                    '...Ah. Voce, RED.',
                    'Ainda se gabando de ser um grande treinador?',
                    'Esse seu POLIWHIRL e a unica coisa que voce tem.',
                    'Me chama quando conseguir capturar algo de verdade.'
                ];
            } else if (!GS.story.gotSaur) {
                return [
                    '...Voce viu aquela luz estranha tambem?',
                    'O velho esta obcecado com isso.',
                    'Um papo de POKeMON lendario...',
                    'Seja o que for, eu vou capturar antes de voce.'
                ];
            } else if (!GS.story.metBlue) {
                GS.story.metBlue = true;
                return [
                    'Entao o velho te deu um BULBASAUR? Grande coisa.',
                    'Ele me deu um CHARMANDER. Muito mais forte.',
                    'Eu sou o BLUE. Eu treino POKeMON para vencer.',
                    'Vamos ver quem e o verdadeiro melhor.',
                    '...Ate mais, RED.'
                ];
            } else {
                return [
                    'O que foi agora? Ainda por aqui?',
                    'Eu ja estou na frente. Como sempre.',
                    'Ate mais.'
                ];
            }
        }
        
        // Girl NPC
        if (npc.name === 'Girl') {
            if (!GS.story.sawMew) {
                return [
                    'Bem-vindo a PALLET TOWN!',
                    'Esse RED vive se gabando...',
                    '"Vou ser o maior treinador!"',
                    'Mas ele so tem um POKeMON!'
                ];
            } else if (!GS.story.gotSaur) {
                return [
                    'Voce viu aquela luz na floresta?!',
                    'O Professor OAK disse que pode ser o MEW!',
                    'Tomara que nao seja perigoso...'
                ];
            } else {
                return [
                    'Uau, o professor te deu um BULBASAUR!',
                    'Voce e o BLUE agora sao treinadores!',
                    'Ouvi dizer que a TEAM ROCKET foi vista ao norte...',
                    'Eles capturam POKeMON raros para coisas horriveis!'
                ];
            }
        }
        
        // Mom
        if (npc.name === 'Mom') {
            if (!GS.story.sawMew) {
                return [
                    'RED, pare de se gabar para as outras criancas!',
                    'Eu sei que voce criou o POLI sozinho, mas...',
                    'Talvez o Professor OAK te ensine um pouco de humildade.'
                ];
            } else if (!GS.story.gotSaur) {
                return [
                    'RED! O Professor OAK estava te procurando!',
                    'Ele disse que viu aquela luz na floresta tambem!',
                    'Vá ao laboratorio, rapido!'
                ];
            } else {
                return [
                    'Meu RED... agora um treinador de POKeMON de verdade.',
                    'POLI e SAUR tem sorte de ter voce.',
                    'Tome cuidado la fora... e apareca de vez em quando.'
                ];
            }
        }
        
        // Daisy (Blue's sister)
        if (npc.name === 'Daisy') {
            if (!GS.story.gotSaur) {
                return [
                    'Procurando o BLUE? Ele foi ao laboratorio do vovo.',
                    'Ele estava todo animado... o vovo deu um POKeMON a ele.',
                    'Um CHARMANDER, eu acho...'
                ];
            } else {
                return [
                    'Entao o vovo te deu um POKeMON tambem!',
                    'O BLUE passou aqui se gabando do CHARMANDER.',
                    'Voces dois sempre foram rivais, ne?'
                ];
            }
        }
        
        // Prof Oak (when talked to directly via handleA)
        if (npc.name === 'Prof. Oak') {
            if (!GS.story.sawMew) {
                return [
                    'Ah, RED! Entre, entre!',
                    'Voce notou algo estranho na floresta ultimamente?',
                    'Tenho registrado leituras de energia... incomuns.'
                ];
            } else if (!GS.story.gotSaur) {
                // This shouldn't happen often - warp handles it
                return [
                    'RED! Ainda bem que veio. Preciso te mostrar algo!'
                ];
            } else {
                return [
                    'Como o POLI esta?',
                    'Lembre: a POKeDEX registra dados automaticamente.',
                    'VIRIDIAN CITY fica ao norte. E um bom primeiro destino.',
                    'Mas tenha cuidado... ja vi sinais da TEAM ROCKET pela area.'
                ];
            }
        }

        if (npc.name === 'Brock') {
            if (!GS.story.caughtPika) {
                return [
                    'Voce parece ter pressa, RED.',
                    'Antes de pensar em desafios maiores...',
                    'Proteja os POKeMON desta cidade.'
                ];
            }
            if (!GS.story.brockBattleDone) {
                return [
                    'Entao foi voce quem enfrentou a TEAM ROCKET.',
                    'Mostre sua determinacao no campo.',
                    'Eu, BROCK, vou testar sua base de treinador.'
                ];
            }
            return [
                'Seu elo com POLI, SAUR e PIKA esta mais forte.',
                'Continue. A jornada em KANTO so comecou.'
            ];
        }
        
        // Default: return static dialog if exists
        return npc.dialog || ['...'];
    }
    
    function handleA() {
        if (inBattle && battle && battle.pending) { battleOk(); return; }
        if (dialog) { nextDialog(); return; }
        if (cutsceneLock) return;
        const map = MAPS[GS.map];
        if (!map) return;
        let tx = GS.px, ty = GS.py;
        if (GS.dir === 'up') ty--;
        else if (GS.dir === 'down') ty++;
        else if (GS.dir === 'left') tx--;
        else if (GS.dir === 'right') tx++;

        // Sign interaction (tile-based)
        if (tx >= 0 && ty >= 0 && tx < map.w && ty < map.h) {
            const t = map.data[ty * map.w + tx];
            if (t === T.SIGN) {
                handleSign(GS.map, tx, ty);
                return;
            }
        }

        if (!map.npcs) return;
        for (const n of map.npcs) {
            if (n.x === tx && n.y === ty) {
                if (n.name === 'Brock' && GS.story.caughtPika && !GS.story.brockBattleDone) {
                    if (playBeat('ch1_brock_intro')) return;
                }
                const dynamicDialog = getDynamicDialog(n);
                showDialog(n.name, dynamicDialog);
                return;
            }
        }
    }

    function handleSign(mapId, x, y) {
        if (mapId === 'pallet_town') {
            showDialog('', [
                'PALLET TOWN',
                'Uma cidade pequena, mas cheia de sonhos.'
            ]);
            return;
        }
        if (mapId === 'viridian') {
            showDialog('', [
                'VIRIDIAN CITY',
                'O GINASIO esta fechado.'
            ]);
            return;
        }
        if (mapId === 'pewter') {
            showDialog('', [
                'PEWTER CITY',
                'A cidade das rochas.'
            ]);
            return;
        }
        if (mapId === 'viridian_forest') {
            showDialog('', [
                'VIRIDIAN FOREST',
                'Insetos e POKeMON selvagens por toda parte.',
                'Fique atento.'
            ]);
            return;
        }
        if (mapId === 'route1' || mapId === 'route2' || mapId === 'route3') {
            showDialog('', [
                mapId.toUpperCase().replace('_', ' '),
                'Rota de transicao entre cidades.',
                'Treinadores e encontros podem acontecer aqui.'
            ]);
            return;
        }
        if (mapId === 'indigo_plateau') {
            showDialog('', [
                'INDIGO PLATEAU',
                'A liga POKeMON de KANTO.'
            ]);
            return;
        }
        showDialog('', ['...']);
    }
    
    function handleB(ev) {
        // Pointer/touch already controls B hold via setRunPressed().
        if (ev) return;
        // Keyboard fallback: toggle run mode.
        setRunPressed(!runPressed);
    }

    function dbg(msg) {
        const bar = document.getElementById('debugBar');
        if (!bar) return;
        if (bar.style.display !== 'block') return;
        bar.textContent = String(msg || '');
    }

    function enableDebugIfNeeded() {
        const bar = document.getElementById('debugBar');
        if (!bar) return;
        const enabled = (new URLSearchParams(location.search)).get('debug') === '1';
        if (enabled) bar.style.display = 'block';
    }

    enableDebugIfNeeded();
    window.addEventListener('error', (e) => {
        dbg(`ERROR: ${e.message || e.type || 'unknown'} @ ${e.filename || ''}:${e.lineno || ''}`);
    });
    window.addEventListener('unhandledrejection', (e) => {
        dbg(`PROMISE: ${e.reason ? (e.reason.message || String(e.reason)) : 'unknown'}`);
    });

    let lastTapAt = 0;
    let tapBusy = false;
    function tapAdvance(e) {
        if (e && e.type === 'click') return;
        if (e && e.type === 'touchstart' && typeof window !== 'undefined' && window.PointerEvent) return;
        if (tapBusy) return;
        try {
            tapBusy = true;
            const now = Date.now();
            // iOS often fires duplicated pointer/touch bursts; debounce to avoid reentry.
            if (now - lastTapAt < 220) return;
            lastTapAt = now;

            if (e && typeof e.preventDefault === 'function') e.preventDefault();
            if (e && typeof e.stopPropagation === 'function') e.stopPropagation();
            dbg(`tapAdvance: dialog=${!!dialog} q=${Array.isArray(dialogQ) ? dialogQ.length : 'NA'} map=${GS.map}`);
            // Fail-safe: when a dialog is open, advance it directly (do not route through handleA()).
            if (inBattle && battle && battle.pending) { battleOk(); return; }
            if (dialog) { nextDialog(); return; }
            if (cutsceneLock) return;
            handleA();
        } catch (err) {
            dbg(`tapAdvance threw: ${err && err.message ? err.message : String(err)}`);
            // Fail open: clear dialog state so the game doesn't brick.
            dialog = null;
            dialogQ = [];
            activeBeatId = null;
            cutsceneLock = false;
            const box = document.getElementById('dialogBox');
            if (box) box.style.display = 'none';
            const ov = document.getElementById('tapOverlay');
            if (ov) ov.style.display = 'none';
        } finally {
            setTimeout(() => { tapBusy = false; }, 90);
        }
    }

    const tapOverlayEl = document.getElementById('tapOverlay');
    const dialogBoxEl = document.getElementById('dialogBox');
    // Single input path to avoid duplicate handlers/races on mobile browsers.
    if (typeof window !== 'undefined' && window.PointerEvent) {
        tapOverlayEl.addEventListener('pointerdown', tapAdvance);
        dialogBoxEl.addEventListener('pointerdown', tapAdvance);
        canvas.addEventListener('pointerdown', tapAdvance);
    } else {
        tapOverlayEl.addEventListener('touchstart', tapAdvance, {passive: false});
        dialogBoxEl.addEventListener('touchstart', tapAdvance, {passive: false});
        canvas.addEventListener('touchstart', tapAdvance, {passive: false});
        tapOverlayEl.addEventListener('mousedown', tapAdvance);
        dialogBoxEl.addEventListener('mousedown', tapAdvance);
        canvas.addEventListener('mousedown', tapAdvance);
    }
    
    const keyToDir = (k) => {
        if (k === 'ArrowUp' || k === 'w' || k === 'W') return 'up';
        if (k === 'ArrowDown' || k === 's' || k === 'S') return 'down';
        if (k === 'ArrowLeft' || k === 'a' || k === 'A') return 'left';
        if (k === 'ArrowRight' || k === 'd' || k === 'D') return 'right';
        return null;
    };
    const dirPressed = {up: false, down: false, left: false, right: false};
    const dirOrder = [];
    const activeDir = () => {
        for (let i = dirOrder.length - 1; i >= 0; i--) {
            const d = dirOrder[i];
            if (dirPressed[d]) return d;
        }
        return null;
    };
    const pressDir = (d) => {
        dirPressed[d] = true;
        const idx = dirOrder.indexOf(d);
        if (idx >= 0) dirOrder.splice(idx, 1);
        dirOrder.push(d);
        const a = activeDir();
        if (a) startMove(a);
    };
    const releaseDir = (d) => {
        dirPressed[d] = false;
        const a = activeDir();
        if (a) startMove(a);
        else stopMove();
    };

    document.addEventListener('keydown', e => {
        const d = keyToDir(e.key);
        if (d) {
            e.preventDefault();
            if (!dirPressed[d]) pressDir(d);
            return;
        }
        if (e.key === 'Shift' || e.key === 'b' || e.key === 'B') {
            setRunPressed(true);
            return;
        }
        if (e.key === 'Enter' || e.key === 'z' || e.key === 'Z' || e.key === 'x' || e.key === 'X') {
            e.preventDefault();
            handleA();
        }
    });
    document.addEventListener('keyup', e => {
        const d = keyToDir(e.key);
        if (d) {
            e.preventDefault();
            releaseDir(d);
            return;
        }
        if (e.key === 'Shift' || e.key === 'b' || e.key === 'B') {
            setRunPressed(false);
        }
    });
    window.addEventListener('blur', () => {
        stopMove();
        setRunPressed(false);
        dirPressed.up = dirPressed.down = dirPressed.left = dirPressed.right = false;
        dirOrder.length = 0;
    });
    // iPad/Safari fail-safe: guarantee movement stops when touch/pointer lifecycle ends.
    window.addEventListener('pointerup', stopMove, true);
    window.addEventListener('pointercancel', stopMove, true);
    window.addEventListener('mouseup', stopMove, true);
    window.addEventListener('touchend', stopMove, {capture: true, passive: true});
    window.addEventListener('touchcancel', stopMove, {capture: true, passive: true});
    window.addEventListener('pagehide', () => {
        stopMove();
        setRunPressed(false);
        dirPressed.up = dirPressed.down = dirPressed.left = dirPressed.right = false;
        dirOrder.length = 0;
    });
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState !== 'visible') {
            stopMove();
            setRunPressed(false);
            dirPressed.up = dirPressed.down = dirPressed.left = dirPressed.right = false;
            dirOrder.length = 0;
        }
    });
    
    // ==================== SAVE/LOAD ====================
    const SAVE_KEY = 'pokemon_adv';
    const SAVE_BAK_KEY = 'pokemon_adv_bak';
    const SAVE_META_KEY = 'pokemon_adv_meta';
    let saveQueued = false;

    function readStorage(key) {
        try { return localStorage.getItem(key); } catch { return null; }
    }

    function writeStorage(key, val) {
        try {
            localStorage.setItem(key, val);
            return true;
        } catch {
            return false;
        }
    }

    function scheduleSave(reason = 'queued') {
        if (saveQueued) return;
        saveQueued = true;
        setTimeout(() => {
            saveQueued = false;
            saveGame(reason);
        }, 80);
    }

    function saveGame(reason = 'manual') {
        const payload = JSON.stringify(GS);
        const prev = readStorage(SAVE_KEY);
        if (prev) writeStorage(SAVE_BAK_KEY, prev);
        if (writeStorage(SAVE_KEY, payload)) {
            writeStorage(SAVE_META_KEY, JSON.stringify({
                at: Date.now(),
                reason,
                map: GS.map,
                px: GS.px,
                py: GS.py
            }));
        }
    }
    function migrateSave(gs) {
        if (!gs || typeof gs !== 'object') return gs;
        if (!gs.story || typeof gs.story !== 'object') gs.story = {};
        if (typeof gs.story.chapter !== 'number') gs.story.chapter = 1;
        if (typeof gs.story.season !== 'number') gs.story.season = 1;
        if (typeof gs.story.beat !== 'string') gs.story.beat = 'ch1_intro';
        if (typeof gs.story.visitedViridian !== 'boolean') gs.story.visitedViridian = false;
        if (typeof gs.story.visitedPewter !== 'boolean') gs.story.visitedPewter = false;
        if (typeof gs.story.caughtPika !== 'boolean') gs.story.caughtPika = false;
        if (typeof gs.story.brockBattleDone !== 'boolean') gs.story.brockBattleDone = false;
        if (!Array.isArray(gs.team)) gs.team = [];
        if (!gs.items) gs.items = {potion: 0, pokeball: 0};
        if (!gs.poli) gs.poli = {name: 'POLI', species: 'POLIWHIRL', hp: 28, maxHp: 28, lv: 8, exp: 0};
        if (!gs.saur) gs.saur = {name: 'SAUR', species: 'BULBASAUR', hp: 22, maxHp: 22, lv: 5, exp: 0};
        if (!gs.pika) gs.pika = {name: 'PIKA', species: 'PIKACHU', hp: 20, maxHp: 20, lv: 6, exp: 0};
        return gs;
    }
    function loadGame() {
        const primary = readStorage(SAVE_KEY);
        const backup = readStorage(SAVE_BAK_KEY);
        let loaded = null;
        if (primary) {
            try { loaded = JSON.parse(primary); } catch {}
        }
        if (!loaded && backup) {
            try { loaded = JSON.parse(backup); } catch {}
        }
        if (loaded) {
            SceneManager.unloadScene({preserveFlow: false});
            stopRenderLoop();
            GS = migrateSave(loaded);
            ensureWalkablePlayerPosition();
            // Defensive reset for stale runtime flags from previous sessions.
            dialog = null;
            dialogQ = [];
            inBattle = false;
            battle = null;
            activeBeatId = null;
            cutsceneLock = false;
            const dialogBox = document.getElementById('dialogBox');
            const tapOverlay = document.getElementById('tapOverlay');
            const battleScreen = document.getElementById('battleScreen');
            if (dialogBox) dialogBox.style.display = 'none';
            if (tapOverlay) tapOverlay.style.display = 'none';
            if (battleScreen) battleScreen.style.display = 'none';
            document.getElementById('titleScreen').style.display = 'none';
            onMapEnter(GS.map, {preserveFlow: false});
            scheduleSave('load-repair');
            startRenderLoop();
        }
        else alert('No save found!');
    }
    
    function startNewGame() {
        SceneManager.unloadScene({preserveFlow: false});
        stopRenderLoop();
        // Hard reset runtime state to avoid post-cutscene soft-locks.
        dialog = null;
        dialogQ = [];
        inBattle = false;
        battle = null;
        activeBeatId = null;
        cutsceneLock = false;
        const dialogBox = document.getElementById('dialogBox');
        const tapOverlay = document.getElementById('tapOverlay');
        const battleScreen = document.getElementById('battleScreen');
        if (dialogBox) dialogBox.style.display = 'none';
        if (tapOverlay) tapOverlay.style.display = 'none';
        if (battleScreen) battleScreen.style.display = 'none';

        // MANGA-ACCURATE GAME STATE (Pokémon Adventures)
        GS = {
            px: 9, py: 13, dir: 'down', map: 'pallet_town',
            // Story progression (MANGA ACCURATE)
            story: {
                season: 1,
                beat: 'ch1_intro',
                chapter: 1,           // Ch1: VS Mew
                sawMew: false,        // Saw Mew in forest
                talkedToOak: false,   // First talk with Oak
                gotPokedex: false,    // Received Pokedex
                gotSaur: false,       // Received Bulbasaur from Oak
                metBlue: false,       // Met rival Blue
                defeatedBlue1: false, // First battle vs Blue
                metGreen: false,      // Met Green (the thief girl)
                caughtPika: false,    // Pewter rescue arc
                brockBattleDone: false,
            },
            // MANGA ACCURATE: Red already has POLI before the story starts!
            // Poli was Red's first Pokemon that he raised from a Poliwag
            team: [],
            // Red's Pokemon (manga names)
            poli: {name: 'POLI', species: 'POLIWHIRL', hp: 28, maxHp: 28, lv: 8, exp: 0},
            saur: {name: 'SAUR', species: 'BULBASAUR', hp: 22, maxHp: 22, lv: 5, exp: 0},
            pika: {name: 'PIKA', species: 'PIKACHU', hp: 20, maxHp: 20, lv: 6, exp: 0},
            items: {potion: 3, pokeball: 5},
            badges: 0
        };
        ensureWalkablePlayerPosition();
        showMapBanner(GS.map);
        
        document.getElementById('titleScreen').style.display = 'none';
        
        setTimeout(async () => {
            // Manga-first: run story beat from external script (fallback is the old inline flow).
            await ensureStoryLoaded();
            if (!playBeat('ch1_intro')) {
                // If story JSON didn't load yet, keep legacy flow (avoid blank screen).
                showDialog('', [
                    'PALLET TOWN - Uma pequena cidade na regiao de KANTO.',
                    'Aqui vive um garoto que vive se gabando de ser um grande treinador...',
                    'O nome dele e RED.'
                ]);
            }
        }, 500);
        scheduleSave('new-game');
        startRenderLoop();
    }

    function applyStartupQueryFlags() {
        // Useful for iPad/Safari cache-state issues:
        // ?reset=1 clears the local save before boot.
        if (qs('reset', '') === '1') {
            try { localStorage.removeItem(SAVE_KEY); } catch {}
            try { localStorage.removeItem(SAVE_BAK_KEY); } catch {}
            try { localStorage.removeItem(SAVE_META_KEY); } catch {}
        }
    }
    
    setInterval(() => saveGame('interval'), 30000);
    // Watchdog to auto-unlock stale UI/cutscene state that can block movement.
    setInterval(() => { clearOrphanRuntimeLocks(); }, 500);
    
    // Start loading
    applyStartupQueryFlags();
    loadAssets();
    </script>
</body>
</html>
